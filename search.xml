<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[linux单文件大小限制]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/linux%E5%8D%95%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>参考<a href="http://mingyang.blog.51cto.com/2807508/1580314" target="_blank" rel="external">刨根问底：ext3/ext4文件系统最大空间及单个文件大小演算法则</a></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 文件存储 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux IO学习]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/%E7%BD%91%E7%BB%9C/linux%20IO%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>参考<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a><br><a href="http://www.jianshu.com/p/dfd940e7fca2" target="_blank" rel="external">聊聊IO多路复用之select、poll、epoll详解</a><br><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">select、poll、epoll之间的区别总结[整理]</a></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> 文件存储 </category>
            
            <category> 网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 文件存储 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kafka存储实现]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/kafka%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>参考<a href="http://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="external">Kafka文件存储机制那些事</a><br><a href="http://www.369bi.com/kafka%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E5%AE%9E%E7%8E%B0/" target="_blank" rel="external">KafKa数据存储与数据一致性实现</a><br><a href="https://wangzzu.github.io/2016/03/08/kafka-store/" target="_blank" rel="external">Kafka之数据存储</a></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> kafka </tag>
            
            <tag> 文件存储 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python的多线程和Goroutine]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/python%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8CGoroutine/</url>
      <content type="html"><![CDATA[<h2 id="python多线程"><a href="#python多线程" class="headerlink" title="python多线程"></a>python多线程</h2><p>参考<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="external">Python的GIL是什么鬼，多线程性能究竟如何</a><br>GIL全称Global Interpreter Lock,一个防止多线程并发执行机器码的一个Mutex</p>
<blockquote>
<p>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)</p>
</blockquote>
<p>基于pcode数量的调度方式</p>
<p>按照Python社区的想法，操作系统本身的线程调度已经非常成熟稳定了，没有必要自己搞一套。所以Python的线程就是C语言的一个pthread，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。</p>
<p>伪代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    acquire GIL</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1000</span>:</div><div class="line">        do something</div><div class="line">    release GIL</div><div class="line">    /* Give Operating System a chance to do thread scheduling */</div></pre></td></tr></table></figure></p>
<p>这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，从release GIL到acquire GIL之间几乎是没有间隙的。所以当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。<br>GIL的存在导致多线程无法很好的立即多核CPU的并发处理能力。<br>简单的总结下就是：Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。<br>如何避免受到GIL的影响:<br>用multiprocessing替代Thread</p>
<p>multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。</p>
<p>当然multiprocessing也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。</p>
<h2 id="go-并发-goroutine"><a href="#go-并发-goroutine" class="headerlink" title="go 并发 goroutine"></a>go 并发 goroutine</h2><p>参考<a href="http://www.infoq.com/cn/articles/knowledge-behind-goroutine" target="_blank" rel="external">goroutine背后的系统知识</a><br><a href="http://nxlhero.blog.51cto.com/962631/1835887" target="_blank" rel="external">理解Goroutine</a><br>Java里的Thread使用的是线程模型的一对一模型，每一个用户线程都对应着一个内核级线程。<br><img src="/uploads/java-thread.png" alt=""><br>上图有两个CPU，然后有4个Java thread，每个Java thread其实就是一个内核级线程，由内核级线程调度器进行调度，轮流使用两个CPU。内核级线程调度器具有绝对的权力，所以把它放到了下面。内核级线程调度器使用公平的算法让四个线程使用两个CPU。</p>
<p><img src="/uploads/Goroutine.png" alt=""><br>Go的Goroutine是用户级的线程。同样是4个Goroutine，可能只对应了两个内核级线程。Goroutine调度器把4个Goroutine分配到两个内核级线程上，而这两个内核级线程对CPU的使用由内核线程调度器来分配。<br>Goroutine，在启动的内核级线程个数一定情况下（通常与CPU个数相等），那么最先启动的Goroutine会一直占据CPU，其它的Goroutine会starve，饿死.为了避免这种情况,需要协程(coroutine)<br><img src="/uploads/go-coroutine.png" alt=""><br>Goroutine与Coroutine不一样，开发者并不需要关心Goroutine如何被调起，如何放弃控制权，而是交给Goroutine调度器来管理。开发者不用关心，但是Go语言的编译器会替你把工作做了，因为Goroutine必须主动交出控制权才能由调度器统一管理。</p>
<p>Go语言通过goroutine提供了目前为止所有(我所了解的)语言里对于并发编程的最清晰最直接的支持，Go语言的文档里对其特性也描述的非常全面甚至超过了，在这里，基于我们上面的系统知识介绍，列举一下goroutine的特性，算是小结：</p>
<p>goroutine是Go语言运行库的功能，不是操作系统提供的功能，goroutine不是用线程实现的。具体可参见Go语言源码里的pkg/runtime/proc.c</p>
<p>goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</p>
<p>除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine</p>
<p>goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用Gosched()来让出CPU</p>
<p>和所有其他并发框架里的协程一样，goroutine里所谓“无锁”的优点只在单线程下有效，如果$GOMAXPROCS &gt; 1并且协程间需要通信，Go运行库会负责加锁保护数据，这也是为什么sieve.go这样的例子在多CPU多线程时反而更慢的原因</p>
<p>Web等服务端程序要处理的请求从本质上来讲是并行处理的问题，每个请求基本独立，互不依赖，几乎没有数据交互，这不是一个并发编程的模型，而并发编程框架只是解决了其语义表述的复杂性，并不是从根本上提高处理的效率，也许是并发连接和并发编程的英文都是concurrent吧，很容易产生“并发编程框架和coroutine可以高效处理大量并发连接”的误解。</p>
<p>Go语言运行库封装了异步IO，所以可以写出貌似并发数很多的服务端，可即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用IO事件驱动设计的、按照事务类型划分好合适比例的线程池。在响应时间上，协作式调度是硬伤。</p>
<p>goroutine最大的价值是其实现了并发协程和实际并行执行的线程的映射以及动态扩展，随着其运行库的不断发展和完善，其性能一定会越来越好，尤其是在CPU核数越来越多的未来，终有一天我们会为了代码的简洁和可维护性而放弃那一点点性能的差别。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux页缓存机制 Page Cache]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E9%A1%B5%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%20Page%20Cache/</url>
      <content type="html"><![CDATA[<p>参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cache/" target="_blank" rel="external">Linux 内核的文件 Cache 管理机制介绍</a><br><a href="http://blog.csdn.net/xf_xjtu/article/details/46382119" target="_blank" rel="external">Linux Page Cache机制</a><br>在 Linux 中，具体文件系统，如 ext2/ext3、jfs、ntfs 等，负责在文件 Cache和存储设备之间交换 数据，位于具体文件系统之上的虚拟文件系统VFS负责在应用程序和文件 Cache 之间通过 read/write 等接口交换 数 据，而内存管理系统负责文件 Cache 的分配和回收，同时虚拟内存管理系统(VMM)则允许应用程序和文件 Cache 之间通过 memory map的方式交换数据。可见，在 Linux 系统中，文件 Cache 是内存管理系统、文件系统以及应用程序之间的一个联系枢纽。<br><a id="more"></a><br><img src="/uploads/linux-fs-cache.jpg" alt=""><br>文件 Cache 分为两个层面，一是 Page Cache，另一个 Buffer Cache，每一个 Page Cache 包含若干 Buffer Cache。内存管理系统和 VFS 只与 Page Cache 交互，内存管理系统负责维护每项 Page Cache 的分配和回收，同时在使用 memory map 方式访问时负责建立映射；VFS 负责 Page Cache 与用户空间的数据交换。而具体文件系统则一般只与 Buffer Cache 交互，它们负责在外围存储设备和 Buffer Cache 之间交换数据。</p>
<p>在 Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这些 Cache 项，一个是 radix tree，另一个是双向链表。<br><img src="/uploads/file-page-block-disk.jpg" alt=""><br><img src="/uploads/page-bufferHead.jpg" alt=""><br><img src="/uploads/radix-tree.gif" alt=""></p>
<p>Linux内核中文件预读算法的具体过程是这样的：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面(不少于一个页面，通常是三个页面)，这时的预读称为同步预读。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的group中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读group扩大一倍，并让底层文件系统读入group中剩下尚不在Cache中的文件数据块，这时的预读称为异步预读。无论第二次读请求是否命中，系统都要更新当前预读group的大小。此外，系统中定义了一个window，它包括前一次预读的group和本次预读的group。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读window中，这时继续进行异步预读并更新相应的window和group；第二种情况是所请求的页面处于预读window之外，这时系统就要进行同步预读并重置相应的window和group。<br><img src="/uploads/linux-filePreRead.gif" alt=""></p>
<p>Linux内核中与文件Cache操作相关的API有很多，按其使用方式可以分成两类：一类是以拷贝方式操作的相关接口， 如read/write/sendfile等，其中sendfile在2.6系列的内核中已经不再支持；<br><img src="/uploads/copy-file.gif" alt=""><br>另一类是以地址映射方式操作的相关接口，如mmap等。<br>第二种类型的API将Cache项映射到用户空间，使得应用程序可以像使用内存指针一样访问文件，Memory map访问Cache的方式在内核中是采用请求页面机制实现的<br><img src="/uploads/memory-ap.gif" alt=""><br>首先，应用程序调用mmap（图中1），陷入到内核中后调用do_mmap_pgoff（图中2）。该函数从应用程序的地址空间中分配一段区域作为映射的内存地址，并使用一个VMA（vm_area_struct）结构代表该区域，之后就返回到应用程序（图中3）。当应用程序访问mmap所返回的地址指针时（图中4），由于虚实映射尚未建立，会触发缺页中断（图中5）。之后系统会调用缺页中断处理函数（图中6），在缺页中断处理函数中，内核通过相应区域的VMA结构判断出该区域属于文件映射，于是调用具体文件系统的接口读入相应的Page Cache项（图中7、8、9），并填写相应的虚实映射表。经过这些步骤之后，应用程序就可以正常访问相应的内存区域了。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[(转)Leveldb实现原理]]></title>
      <url>https://makeitpossible16.github.io/Leveldb/(%E8%BD%AC)Leveldb%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文转自<a href="http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html" target="_blank" rel="external">数据分析与处理之二（Leveldb 实现原理）</a><br>郑重声明：本篇博客是自己学习 Leveldb 实现原理时参考了郎格科技系列博客整理的，原文地址：<a href="http://www.samecity.com/blog/Index.asp?SortID=12" target="_blank" rel="external">http://www.samecity.com/blog/Index.asp?SortID=12</a>, 只是为了加深印象，本文的配图是自己重新绘制的，大部分内容与原文相似，大家可以浏览原始页面 :-)，感兴趣的话可以一起讨论 Leveldb 的实现原理！</p>
<h2 id="LevelDb日知录之一：LevelDb-101"><a href="#LevelDb日知录之一：LevelDb-101" class="headerlink" title="LevelDb日知录之一：LevelDb 101"></a>LevelDb日知录之一：LevelDb 101</h2><p>　　说起LevelDb也许您不清楚，但是如果作为IT工程师，不知道下面两位大神级别的工程师，那您的领导估计会Hold不住了：Jeff Dean和Sanjay Ghemawat。这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。</p>
<p>　　Jeff Dean其人：<a href="http://research.google.com/people/jeff/index.html" target="_blank" rel="external">http://research.google.com/people/jeff/index.html</a>, Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。</p>
<p>　　Sanjay Ghemawat其人：<a href="http://research.google.com/people/sanjay/index.html" target="_blank" rel="external">http://research.google.com/people/sanjay/index.html</a>, Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。</p>
<p>　　LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。</p>
<p>　　LevelDb有如下一些特点：</p>
<p>　　　　首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。</p>
<p>　　　　其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。</p>
<p>　　　　再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。</p>
<p>　　　　另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</p>
<p>　　除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。</p>
<p>　　LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。至于为何是这样，看了我们后续推出的LevelDb日知录，估计您会了解其内在原因。</p>
<h2 id="LevelDb日知录之二：整体架构"><a href="#LevelDb日知录之二：整体架构" class="headerlink" title="LevelDb日知录之二：整体架构"></a>LevelDb日知录之二：整体架构</h2><p>   LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。</p>
<p>   本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb日知录后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。</p>
<p>   LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：<br>     <img src="/uploads/leveldb-1.png" alt=""><br>     <center>图1.1：LevelDb结构</center><br> 从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。</p>
<p> LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p>
<p> Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。</p>
<p> 当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p>
<p> SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。</p>
<p> SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：<br> <img src="/uploads/leveldb-2.png" alt=""><br> <center>图2.1：Manifest存储示意图</center><br> 图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。</p>
<p>Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。</p>
<p>以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb日知录接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。</p>
<h2 id="LevelDb日知录之三：log文件"><a href="#LevelDb日知录之三：log文件" class="headerlink" title="LevelDb日知录之三：log文件"></a>LevelDb日知录之三：log文件</h2><p>上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。</p>
<p>下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。<br><img src="/uploads/leveldb-3.png" alt=""></p>
<p><center>图3.1 log文件布局</center><br>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理，图3.2显示了一个记录在LevelDb内部是如何表示的。<br><img src="/uploads/leveldb-4.png" alt=""></p>
<p><center>图3.2 记录结构</center><br>记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p>
<p> 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p>
<p>假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p>
<p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p>
<h2 id="LevelDb日知录之四：SSTable文件"><a href="#LevelDb日知录之四：SSTable文件" class="headerlink" title="LevelDb日知录之四：SSTable文件"></a>LevelDb日知录之四：SSTable文件</h2><p>SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。</p>
<p>本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb日知录之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。</p>
<p>　　LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。<br><img src="/uploads/leveldb-5.png" alt=""></p>
<p><center>图4.1 .sst文件的分块结构</center><br>图4.1展示了一个.sst文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p>
<p>　　以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了.sst文件的内部逻辑解释。<br><img src="/uploads/leveldb-6.png" alt=""></p>
<p><center>图4.2 逻辑布局</center><br>从图4.2可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p>
<p>　　LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。<br><img src="/uploads/leveldb-7.png" alt=""></p>
<p><center>图4.3 数据索引</center><br>图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。</p>
<p>　　文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。<br><img src="/uploads/leveldb-8.png" alt=""></p>
<p><center>图4.4 Footer</center><br>上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。<br><img src="/uploads/leveldb-9.png" alt=""></p>
<p><center>图4.5 数据Block内部结构</center><br>从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。</p>
<p>　　“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。<br><img src="/uploads/leveldb-10.png" alt=""></p>
<p><center>图4.6 记录格式</center><br>在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。</p>
<p>　　上面讲的这些就是.sst文件的全部内部奥秘。</p>
<h2 id="LevelDb日知录之五：MemTable详解"><a href="#LevelDb日知录之五：MemTable详解" class="headerlink" title="LevelDb日知录之五：MemTable详解"></a>LevelDb日知录之五：MemTable详解</h2><p>LevelDb日知录前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。</p>
<p>　　LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。</p>
<p>　　需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。</p>
<p>　　SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。</p>
<p>SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。</p>
<p>关于SkipList的详细介绍可以参考这篇文章：<a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html" target="_blank" rel="external">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html</a>, 讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。</p>
<p>　　SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。</p>
<h2 id="LevelDb日知录之六-写入与删除记录"><a href="#LevelDb日知录之六-写入与删除记录" class="headerlink" title="LevelDb日知录之六 写入与删除记录"></a>LevelDb日知录之六 写入与删除记录</h2><p>在之前的五节LevelDb日知录中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。</p>
<p> 本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。<br> <img src="/uploads/leveldb-11.png" alt=""><br> <center>图6.1 LevelDb写入记录</center><br> 图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。</p>
<p>从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。</p>
<p>levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。</p>
<h2 id="LevelDb日知录之七：读取记录"><a href="#LevelDb日知录之七：读取记录" class="headerlink" title="LevelDb日知录之七：读取记录"></a>LevelDb日知录之七：读取记录</h2><p>LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。</p>
<pre><code>假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。
</code></pre><p><img src="/uploads/leveldb-12.png" alt=""></p>
<p><center>图7-1  LevelDb读取记录流程</center><br>LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p>
<p> 　　那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。</p>
<p> 　　为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”www.samecity.com”  value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”www.samecity.com”  value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”www.samecity.com”,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。</p>
<p>　　前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。</p>
<p>　　SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。</p>
<p>　　最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。</p>
<p>　　从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。</p>
<h2 id="LevelDb日知录之八：Compaction操作"><a href="#LevelDb日知录之八：Compaction操作" class="headerlink" title="LevelDb日知录之八：Compaction操作"></a>LevelDb日知录之八：Compaction操作</h2><p>前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。</p>
<p>levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。</p>
<p>LevelDb包含其中两种，minor和major。</p>
<p>我们将为大家详细叙述其机理。</p>
<p>先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。<br><img src="/uploads/leveldb-13.png" alt=""></p>
<p><center>图8.1 minor compaction</center><br>从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。</p>
<p>当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。</p>
<p>我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。</p>
<p>　　levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p>
<p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。</p>
<p>　　也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p>
<p>图8.2说明了这一过程。<br><img src="/uploads/leveldb-14.png" alt=""></p>
<p><center>图8.2 SSTable Compaction</center><br>Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。</p>
<p>　　那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。</p>
<h2 id="LevelDb日知录之九-levelDb中的Cache"><a href="#LevelDb日知录之九-levelDb中的Cache" class="headerlink" title="LevelDb日知录之九 levelDb中的Cache"></a>LevelDb日知录之九 levelDb中的Cache</h2><p>书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。</p>
<p>　　levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。<br><img src="/uploads/leveldb-15.png" alt=""></p>
<p><center>图9.1 table cache</center><br>图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。</p>
<p>　　比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。<br><img src="/uploads/leveldb-16.png" alt=""></p>
<p><center>图9.2 block cache</center><br>Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p>
<p>　　如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p>
<h2 id="LevelDb日知录之十-Version、VersionEdit、VersionSet"><a href="#LevelDb日知录之十-Version、VersionEdit、VersionSet" class="headerlink" title="LevelDb日知录之十 Version、VersionEdit、VersionSet"></a>LevelDb日知录之十 Version、VersionEdit、VersionSet</h2><p>Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？</p>
<p>当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。</p>
<p>　　当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p>
<p>　　VersionSet 是所有Version的集合，管理着所有存活的Version。</p>
<p>　　VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。</p>
<p>Version0 +VersionEdit–&gt;Version1</p>
<p>　　VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。</p>
<p>　　leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。</p>
<p>　　比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。</p>
<p>leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。</p>
<p>注：博文参考了郎格科技博客：<a href="http://www.samecity.com/blog/Index.asp?SortID=12" target="_blank" rel="external">http://www.samecity.com/blog/Index.asp?SortID=12</a></p>
]]></content>
      
        <categories>
            
            <category> Leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用户态到内核态切换]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%94%A8%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E5%88%87%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h2 id="用户态-内核态概念"><a href="#用户态-内核态概念" class="headerlink" title="用户态 内核态概念"></a>用户态 内核态概念</h2><p>引用《深入理解LINUX内核》的一段话:<br>类UNIX操作系统把与计算机物理组织相关的底层细节都对用户运行的程序隐藏起来, 当程序想用硬件资源时,必须向操作系统发出一个请求. 内核对这个请求进行评估,如果允许使用这个资源,那么,内核代表应用程序与相应的硬件进行交互.<br>硬件CPU引入至少两种不同的执行模式: 用户程序的非特权模式和内核的特权模式.unix把它们分别成为用户态和内核态.</p>
<h2 id="用户态和内核态之间进行切换时的代价"><a href="#用户态和内核态之间进行切换时的代价" class="headerlink" title="用户态和内核态之间进行切换时的代价"></a>用户态和内核态之间进行切换时的代价</h2><p>参考<a href="http://www.cnblogs.com/justcxtoworld/p/3155741.html" target="_blank" rel="external">用户态到内核态切换之奥秘解析</a><br>用户态到内核态切换途径：<br> 1：系统调用        2：中断 　　3：异常<br> 在X86中调用int指令型系统调用后会把用户栈的%esp的值及相关寄存器压入内核栈中，系统调用通过iret指令返回，在返回之前会从内核栈弹出用户栈的%esp和寄存器的状态，然后进行恢复。所以在进入内核态之前要保存进程的上下文，中断结束后恢复进程上下文，那靠的就是内核栈。<br> 　　这里有个细节问题，就是要想在内核栈保存用户态的esp,eip等寄存器的值，首先得知道内核栈的栈指针，那在进入内核态之前，通过什么才能获得内核栈的栈指针呢？答案是：TSS(任务状态段)<br>X86体系结构中包括了一个特殊的段类型：任务状态段（TSS），用它来存放硬件上下文。TSS反映了CPU上的当前进程的特权级。<br>linux为每一个cpu提供一个tss段，并且在tr寄存器中保存该段。<br>在从用户态切换到内核态时，可以通过获取TSS段中的esp0来获取当前进程的内核栈 栈顶指针，从而可以保存用户态的cs,esp,eip等上下文。</p>
<p>总结在进程从用户态到内核态切换过程中，Linux主要做的事：</p>
<p>1：读取tr寄存器，访问TSS段</p>
<p>2：从TSS段中的sp0获取进程内核栈的栈顶指针</p>
<p>3:  由控制单元在内核栈中保存当前eflags,cs,ss,eip,esp寄存器的值。</p>
<p>4：由SAVE_ALL保存其寄存器的值到内核栈</p>
<p>5：把内核代码选择符写入CS寄存器，内核栈指针写入ESP寄存器，把内核入口点的线性地址写入EIP寄存器</p>
<p>此时，CPU已经切换到内核态，根据EIP中的值开始执行内核入口点的第一条指令。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[(转)自旋锁spinlock剖析与改进]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%87%AA%E6%97%8B%E9%94%81spinlock%E5%89%96%E6%9E%90%E4%B8%8E%E6%94%B9%E8%BF%9B/</url>
      <content type="html"><![CDATA[<p>遇到题目：<br>运行在多核处理器上的Linux环境中,若临界区非常短,且不允许线程上下文切换的情况下,使用下列哪种机制满足上述需求并且性能最好? SpinLock<br>SpinLock<br>Mutex<br>Semaphore<br>Condition variable<br>对SpinLock 以及Mutex不太了解，参考<a href="http://kb.cnblogs.com/page/105657/" target="_blank" rel="external">自旋锁spinlock剖析与改进</a>,得到比较全面的认识。<br>spinlock又称自旋锁，线程通过busy-wait-loop的方式来获取锁，任时刻只有一个线程能够获得锁，其他线程忙等待直到获得锁。spinlock在多处理器多线程环境的场景中有很广泛的使用，一般要求使用spinlock的临界区尽量简短，这样获取的锁可以尽快释放，以满足其他忙等的线程。Spinlock和mutex不同，spinlock不会导致线程的状态切换(用户态-&gt;内核态)，但是spinlock使用不当(如临界区执行时间过长)会导致cpu busy飙高。<br>spinlock不会使线程状态发生切换，mutex在获取不到锁的时候会选择sleep。</p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LRU缓存淘汰算法]]></title>
      <url>https://makeitpossible16.github.io/%E7%AE%97%E6%B3%95/LRU%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在Linux目录项高速缓存中,所有”未使用”的目录项对象都存放在一个会使用LRU(Last Recently used)算法实现的双向链表中,该链表按照插入的时间进行排序. 最后释放的目录项会放在链表的首部,最近最少使用的目录项对象靠近链表尾部,需要释放空间时,内核从链表尾部进行删除.<br><a id="more"></a><br>参考<a href="http://flychao88.iteye.com/blog/1977653" target="_blank" rel="external">缓存淘汰算法–LRU算法</a>,LRU算法实现:</p>
<ol>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<p>缓存污染: 当存在热点数据时，LRU的效率很好,但偶发性的、周期性的批量操作会导致LRU命中率急剧下降</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[伪随机数]]></title>
      <url>https://makeitpossible16.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>遇到一到面试题,其中提到Hash函数的构造方法可以使用 随机数法:选择一个随机函数，取关键字的随机函数值为它的散列地址,感觉取随机数会导致数据查找失败,不过查找了有关计算机中伪随机数的生成方法后,明白了这个方法是可行的.<br><a id="more"></a><br>解释来自百度百科:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//rand01.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> RAND_SEED;</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    RAND_SEED=(RAND_SEED*<span class="number">123</span>+<span class="number">59</span>)%<span class="number">65536</span>;</div><div class="line">    <span class="keyword">return</span>(RAND_SEED);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">random_start</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> temp[<span class="number">2</span>];</div><div class="line">    movedata(<span class="number">0x0040</span>,<span class="number">0x006c</span>,FP_SEG(temp),FP_OFF(temp),<span class="number">4</span>);</div><div class="line">    RAND_SEED=temp[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line">main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i,n;</div><div class="line">    random_start();</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%u\t"</span>,random());</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">movedata(0x0040,0x006c,FP_SEG(temp),FP_OFF(temp),4);</div></pre></td></tr></table></figure>
<p>这个函数用来移动内存数据，其中FP_SEG（far pointer to segment）是取temp数组段地址的函数，FP_OFF（far pointer to offset）是取temp数组相对地址的函数，movedata函数的作用是把位于0040:006CH存储单元中的双字放到数组temp的声明的两个存储单元中。这样可以通过temp数组把0040:006CH处的一个16位的数送给RAND_SEED。<br>random用来根据随机种子RAND_SEED的值计算得出随机数，其中这一句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RAND_SEED=(RAND_SEED*123+59)%65536</div></pre></td></tr></table></figure></p>
<p>是用来计算随机数的方法，随机数的计算方法在不同的计算机中是不同的，即使在相同的计算机中安装的不同的操作系统中也是不同的。我在linux和windows下分别试过，相同的随机种子在这两种操作系统中生成的随机数是不同的，这说明它们的计算方法不同。<br>0040:006CH处其实这一段内存空间是这样定义的：<br>TIMER_LOW DW ? ；地址为 0040:006CH<br>TIMER_HIGH DW ? ；地址为 0040:006EH<br>TIMER_OFT DB ? ；地址为 0040:0070H<br>时钟中断服务程序中，每当TIMER_LOW转满时，此时，记数器也会转满，记数器的值归零，即TIMER_LOW处的16位二进制归零，而TIMER_HIGH加一。<br>由于随机种子可以人工设定,因此每次产生的随机数都是相同的.<br>Python例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">In [3]: random.seed(1)</div><div class="line">In [4]: for i in range(10):</div><div class="line">   ...:     print random.random()</div><div class="line">   ...:</div><div class="line">0.134364244112</div><div class="line">0.847433736937</div><div class="line">0.763774618977</div><div class="line">0.255069025739</div><div class="line">0.495435087092</div><div class="line">0.449491064789</div><div class="line">0.651592972723</div><div class="line">0.788723351136</div><div class="line">0.0938595867742</div><div class="line">0.028347476522</div><div class="line"></div><div class="line">In [5]: random.seed(1)</div><div class="line"></div><div class="line">In [6]: for i in range(10):</div><div class="line">   ...:     print random.random()</div><div class="line">   ...:</div><div class="line">0.134364244112</div><div class="line">0.847433736937</div><div class="line">0.763774618977</div><div class="line">0.255069025739</div><div class="line">0.495435087092</div><div class="line">0.449491064789</div><div class="line">0.651592972723</div><div class="line">0.788723351136</div><div class="line">0.0938595867742</div><div class="line">0.028347476522</div><div class="line">In [7]:</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 操作系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[(转)文件系统vs对象存储——选型和趋势]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8VS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>之前对于对象存储的定义还是比较模糊，看完<a href="http://www.testlab.com.cn/Index/article/id/1082.html" target="_blank" rel="external">文件系统vs对象存储——选型和趋势</a>这篇文章后对文件系统和对象存储有一个比较清晰的了解，做一下简单的概括。</p>
<h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><p>初期：对象存储往往指的是以类似标准化组织SNIA定义的OSD（object storage device）和MDS（Metadata Server）为基本组成部分的分布式存储，通常是分布式文件系统。<br><img src="/uploads/对象存储1.png" alt=""><br>后期：指的是以AWS的S3为代表的，通过HTTP接口提供访问的存储服务或者存储系统,如果我们把一个文件传到对象存储系统里面存起来，就叫做一个对象。<br><img src="/uploads/对象存储2.png" alt=""></p>
<h2 id="对象存储与文件系统的比较"><a href="#对象存储与文件系统的比较" class="headerlink" title="对象存储与文件系统的比较"></a>对象存储与文件系统的比较</h2><p>对于大多数文件系统来说，尤其是POSIX(表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX ）,POSIX标准定义了操作系统应该为应用程序提供的接口标准)兼容的文件系统，提供open、close、read、write和lseek等接口。<br>而对象存储的接口是REST风格的，通常是基于HTTP协议的RESTful Web API，通过HTTP请求中的PUT和GET等操作进行文件的上传即写入和下载即读取，通过DELETE操作删除文件。<br>对象存储和文件系统在接口上的本质区别是对象存储不支持和fread和fwrite类似的随机位置读写操作，即一个文件PUT到对象存储里以后，如果要读取，只能GET整个文件，如果要修改一个对象，只能重新PUT一个新的到对象存储里，覆盖之前的对象或者形成一个新的版本。</p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件系统，对象存储 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++语法记录]]></title>
      <url>https://makeitpossible16.github.io/C/C++%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>最近遇到一些C++的代码,其中会包含一些C++11及STL的代码,对C++11的特性不太了解,记录一下.</p>
<h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>next用于操作迭代器,函数解释<a href="http://en.cppreference.com/w/cpp/iterator/next" target="_blank" rel="external">std::next</a><br>Parameters<br>  it    -    an iterator<br>  n    -    number of elements to advance<br>使用示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::vector&lt;int&gt; v&#123; 3, 1, 4,6,7 &#125;;</div><div class="line"></div><div class="line">    auto it = v.begin();</div><div class="line"></div><div class="line">    auto nx = std::next(it, 3);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; *it &lt;&lt; &apos; &apos; &lt;&lt; *nx &lt;&lt; &apos;\n&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">output:</div><div class="line">3 6</div></pre></td></tr></table></figure></p>
<h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p><a href="http://www.cnblogs.com/scandy-yuan/archive/2013/01/07/2849735.html" target="_blank" rel="external">STL之vector容器详解</a><br>函数将一个新的元素加到vector的最后面，位置为当前最后一个元素的下一个元素. 参考<a href="http://blog.csdn.net/u010545732/article/details/24385701" target="_blank" rel="external">C++ vector::push_back 用法剖析</a></p>
<h2 id="for-each"><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h2><p>for_each用于逐个遍历容器元素，它对迭代器区间[first，last)所指的每一个元素，执行由单参数函数对象f所定义的操作。<br>参考<a href="http://blog.csdn.net/jerryjbiao/article/details/6827508" target="_blank" rel="external">简单的程序诠释C++ STL算法系列之一：for_each</a></p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>参考<a href="http://www.cnblogs.com/hailexuexi/archive/2012/04/10/2440209.html" target="_blank" rel="external">C++ map的基本操作和使用</a><br>C++中map容器提供一个键值对容器，map与multimap差别仅仅在于multimap允许一个键对应多个值。<br>使用时需要包含头文件<br>#include<map><br>在map中插入元素,enumMap[1] = “One”;这样非常直观，但存在一个性能的问题。插入2时,先在enumMap中查找主键为2的项，没发现，然后将一个新的对象插入enumMap，键是2，值是一个空字符串，插入完成后，将字符串赋为”Two”; 该方法会将每个值都赋为缺省值，然后再赋为显示的值，如果元素是类对象，则开销比较大。我们可以用以下方法来避免开销：<br>enumMap.insert(map<int, cstring=""> :: value_type(2, “Two”))<br>查找并获取map中的元素:<br>CString tmp = enumMap[2];<br>但是,只有当map中有这个键的实例时才对，否则会自动插入一个实例，值为初始化值。<br>查找map中是否包含某个关键字条目用find()方法，传入的参数是要查找的key，在这里需要提到的是begin()和end()两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator.<br>int nFindKey = 2; //要查找的Key<br>//定义一个条目变量(实际是指针)<br>UDT_MAP_INT_CSTRING::iterator it= enumMap.find(nFindKey);<br>if(it == enumMap.end()) {<br>//没找到<br>}<br>else {<br>//找到<br>}<br>通过map对象的方法获取的iterator数据类型是一个std::pair对象，包括两个数据 iterator-&gt;first 和 iterator-&gt;second 分别代表关键字和存储的数据<br>//删除<br>map<string,cagent>::iterator iter=m_AgentClients.find(pSocket-&gt;GetName());<br> if(iter!=m_AgentClients.end())<br> {</string,cagent></int,></map></p>
<pre><code>m_AgentClients.erase(iter);//列表移除
</code></pre><p> }</p>
<h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><p> 参考<a href="http://www.169it.com/article/16084623434929200925.html" target="_blank" rel="external">c++ stl multimap基本操作使用技巧详细介绍</a><br> C++ stl  Multimap 和C++ stl  map 很相似，但是MultiMap允许重复的元素。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C++11 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gdb调试错误-找不到文件]]></title>
      <url>https://makeitpossible16.github.io/linux%E5%91%BD%E4%BB%A4/gdb%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF-%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>使用gdb进行调试时出现错误,错误重现:<br>(gdb) q<br>sh-4.3$ gdb -q aaa<br>Reading symbols from aaa…done.<br>(gdb) l<br>28              int base = factorial(n - 1);<br>29              –k;<br>30              for (int i = n -1; i &gt; 0; k %= base, base /= i, –i) {<br>31                  auto a = next(S.begin(), k / base);<br>32                  result.push_back(*a);<br>33                  S.erase(a);<br>34              }<br>35              cout &lt;&lt; S[0];<br>36              auto a = S[0];<br>37              // result.push_pack(a);<br>(gdb) b 37<br>Breakpoint 1 at 0x4012a2: file /home/ubuntu/workspace/leetcode/permutation_sequence.cpp, line 37.<br>(gdb) r<br>Starting program: /home/ubuntu/workspace/leetcode/aaa<br>Cannot exec  -c exec /home/ubuntu/workspace/leetcode/aaa .<br>Error: 没有那个文件或目录<br>During startup program exited with code 127.</p>
<p>在vscode中,错误提示为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Unable to start debugging. Unexpected GDB output from command &quot;-exec-run&quot;. During startup program exited with code 127.</div></pre></td></tr></table></figure></p>
<p>解决方法:<br>参考<a href="http://unix.stackexchange.com/questions/167918/gdb-cannot-exec-my-test-program" target="_blank" rel="external">http://unix.stackexchange.com/questions/167918/gdb-cannot-exec-my-test-program</a>,由于SHELL变量不存在,导致gdb抛出异常,解决方法:<br>在/etc//etc/environment中设置全局变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export SHELL=/bin/sh</div><div class="line">或</div><div class="line">export SHELL=/bin/bash</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode解题-Next Permutation(全排列生成算法)]]></title>
      <url>https://makeitpossible16.github.io/%E7%AE%97%E6%B3%95/LeetCode%E8%A7%A3%E9%A2%98-Next%20Permutation(%E5%85%A8%E6%8E%92%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95)/</url>
      <content type="html"><![CDATA[<p>LeetCode题目-Next Permutation<br>看半天连题目都看不懂,参考<a href="http://blog.csdn.net/nomasp/article/details/49913627" target="_blank" rel="external">LeetCode 31 Next Permutation（下一个排列）</a>,基本理解题意:<br>数学中的排列组合，比如“1，2，3”的全排列，依次是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 2 3</div><div class="line">1 3 2</div><div class="line">2 1 3</div><div class="line">2 3 1</div><div class="line">3 1 2</div><div class="line">3 2 1</div></pre></td></tr></table></figure></p>
<p>从上面的某一行重排到期下一行，如果已经是最后一行了，则重排成第一行。</p>
<p>实现思路:<br>从后往前遍历,找到最长递增序列,结束位置为index,然后找到最长递增序列中比index-1的数大的最小的数.<br>图片来源:<a href="http://fisherlei.blogspot.co.id/2012/12/leetcode-next-permutation.html" target="_blank" rel="external">http://fisherlei.blogspot.co.id/2012/12/leetcode-next-permutation.html</a><br><img src="/uploads/next permutation.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[swift-weedfs-backend diskfile代码实现]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/swift-weedfs-backend%20diskfile%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>主要修改InMemoryFileSystem中的代码,使用seaweedfs进行数据持久化,完整代码实现<a href="https://github.com/MakeItPossible16/swift-weedfs-backend" target="_blank" rel="external">swift-weedfs-backend</a><br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InMemoryFileSystem</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    A very simplistic in-memory file system scheme.</div><div class="line"></div><div class="line">    There is one dictionary mapping a given object name to a tuple. The first</div><div class="line">    entry in the tuple is the cStringIO buffer representing the file contents,</div><div class="line">    the second entry is the metadata dictionary.</div><div class="line">    """</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self._filesystem = &#123;&#125;</div><div class="line">        self.seaweedfs = Seaweedfs_operation()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_object</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Return back an file-like object and its metadata</div><div class="line"></div><div class="line">        :param name: standard object name</div><div class="line">        :return (fp, metadata): fp is `StringIO` in-memory representation</div><div class="line">                                object (or None). metadata is a dictionary</div><div class="line">                                of metadata (or None)</div><div class="line">        """</div><div class="line">        <span class="comment"># val = self._filesystem.get(name)</span></div><div class="line">        val = self.seaweedfs.GET(name)</div><div class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            fp, metadata = <span class="keyword">None</span>, <span class="keyword">None</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            fp, metadata = self.parse_seaweedfs_file(val)</div><div class="line">        <span class="comment"># else:</span></div><div class="line">        <span class="comment">#     fp, metadata = val</span></div><div class="line">        <span class="keyword">return</span> fp, metadata</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse_seaweedfs_file</span><span class="params">(self,val)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        parse file download from seaweedfs</div><div class="line">        :param val: seaweedfs file,fomat: str(metadata) + '\n' + obj_content</div><div class="line">        :return: StringIO obj_content, python dict metadata</div><div class="line">        """</div><div class="line">        metadata_index = val.find(<span class="string">'\n'</span>)</div><div class="line">        val = val.split(<span class="string">'\n'</span>,<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span>  StringIO.StringIO(val[<span class="number">1</span>]),eval(val[<span class="number">0</span>])</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put_object</span><span class="params">(self, name, fp, metadata)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Store object into seaweedfs</div><div class="line"></div><div class="line">        :param name: standard object name</div><div class="line">        :param fp: `StringIO` in-memory representation object</div><div class="line">        :param metadata: dictionary of metadata to be written</div><div class="line">        """</div><div class="line">        <span class="comment"># self._filesystem[name] = (fp, metadata)</span></div><div class="line">        fp.seek(<span class="number">0</span>)</div><div class="line">        self.seaweedfs.PUT(name,str(metadata) + <span class="string">'\n'</span> + fp.read())</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">del_object</span><span class="params">(self, name)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Delete object from memory</div><div class="line"></div><div class="line">        :param name: standard object name</div><div class="line">        """</div><div class="line">        <span class="comment"># import pydevd</span></div><div class="line">        <span class="comment"># pydevd.settrace('127.0.0.1', port=54321, stdoutToServer=True, stderrToServer=True)</span></div><div class="line">        self.seaweedfs.DELETE(name)</div><div class="line">        <span class="comment"># del self._filesystem[name]</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_diskfile</span><span class="params">(self, account, container, obj, **kwargs)</span>:</span></div><div class="line">        <span class="keyword">return</span> DiskFile(self, account, container, obj)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pickle_async_update</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        For now don't handle async updates.</div><div class="line">        """</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
            <tag> seaweedfs </tag>
            
            <tag> swift-weedfs-backend </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode解题-Next Permutation(全排列生成算法)]]></title>
      <url>https://makeitpossible16.github.io/%E7%AE%97%E6%B3%95/LeetCode%E8%A7%A3%E9%A2%98-Permutation%20Sequence/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h2><p>给出数字n,在1…n的全排列组合中找到第k个,如: n = 3, k=3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">全排列:</div><div class="line">123</div><div class="line">132</div><div class="line">213</div><div class="line">231</div><div class="line">312</div><div class="line">321</div></pre></td></tr></table></figure></p>
<p>结果为:213</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>使用逆康托编码展开,参考<a href="http://www.cnblogs.com/zhanjxcom/p/5596208.html" target="_blank" rel="external">全排列的编码与解码——康托展开</a></p>
<h3 id="康托编码"><a href="#康托编码" class="headerlink" title="康托编码:"></a>康托编码:</h3><p>{1,2,3,4,…,n}的排列总共有n!种，将它们从小到大排序，怎样知道其中一种排列是有序序列中的第几个？<br>如 {1,2,3} 按从小到大排列一共6个：123 132 213 231 312 321。想知道321是{1,2,3}中第几个大的数。<br>小于3的数有1和2 两个，首位确定之后后面两位有2！中情况，所以共有2<em>2！=4种。<br>小于2的数只有一个1，所以有1</em>1！=1种情况，最后一位是1，没有比一小的数，所以是0<em>0！=0<br>综上：小于321的数有4+1=5个，所以321是第六小的数。<br>例如:排列3 5 7 4 1 2 9 6 8展开为98884<br>X=2</em>8!+3<em>7!+4</em>6!+2<em>5!+0</em>4!+0<em>3!+2</em>2!+0<em>1!+0</em>0!=98884.</p>
<h3 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开:"></a>逆康托展开:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">如何找出第16个（按字典序的）&#123;1,2,3,4,5&#125;的全排列？</div><div class="line"></div><div class="line">1. 首先用16-1得到15</div><div class="line"></div><div class="line">2. 用15去除4! 得到0余15</div><div class="line"></div><div class="line">3. 用15去除3! 得到2余3</div><div class="line"></div><div class="line">4. 用3去除2! 得到1余1</div><div class="line"></div><div class="line">5. 用1去除1! 得到1余0</div><div class="line"></div><div class="line">有0个数比它小的数是1，所以第一位是1</div><div class="line"></div><div class="line">有2个数比它小的数是3，但1已经在之前出现过了所以是4</div><div class="line"></div><div class="line">有1个数比它小的数是2，但1已经在之前出现过了所以是3</div><div class="line"></div><div class="line">有1个数比它小的数是2，但1,3,4都出现过了所以是5</div><div class="line"></div><div class="line">最后一个数只能是2</div><div class="line"></div><div class="line">所以排列为1 4 3 5 2</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[swift-weedfs-backend接口设计]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/swift-weedfs-backend%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>swift-weedfs-backend基于mem_diskfile,使用seaweedfs对mem_diskfile中的数据进行持久化.<br>设计接口如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">接口名称</th>
<th>参数类型:参数名称</th>
<th>返回值</th>
<th>接口说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td>strng:url</td>
<td>file_content</td>
<td>获取seaweedfs文件</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td>string:url,obj_content</td>
<td>True/False</td>
<td>保存对象</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td>string:url</td>
<td>True/False</td>
<td>删除对象</td>
</tr>
<tr>
<td style="text-align:left">parseURL</td>
<td>string:url</td>
<td>account,container,obj_name</td>
<td>从URL中解析得到account,container,obj_name</td>
</tr>
</tbody>
</table>
<p>代码实现:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seaweedfs_operation</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.seaweedfs = WeedFS();</div><div class="line">        self.filter_ip = <span class="string">"127.0.0.1"</span></div><div class="line">        self.filter_port = <span class="string">"8888"</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PUT</span><span class="params">(self,url, obj_content)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        upload file to seaweedfs</div><div class="line">        :param url:</div><div class="line">        :param obj_content:</div><div class="line">        :return: obj size</div><div class="line">        """</div><div class="line">        account,container,obj_name = self.parseURL(url)</div><div class="line">        url_complete = <span class="string">u"http://&#123;filter_ip&#125;:&#123;filter_port&#125;/&#123;account&#125;/&#123;container&#125;/"</span>.format(filter_ip=self.filter_ip,</div><div class="line">                                                                                         filter_port=self.filter_port,</div><div class="line">                                                                                         account=account,container=container)</div><div class="line">        <span class="keyword">return</span> self.seaweedfs.upload_file(url_complete,obj_name,obj_content)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DELETE</span><span class="params">(self,url)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        delete a file from seaweedfs</div><div class="line">        :param url:</div><div class="line">        :return: Boolean: True:delete success</div><div class="line">        """</div><div class="line">        url_complete = <span class="string">u"http://&#123;filter_ip&#125;:&#123;filter_port&#125;&#123;url&#125;"</span>.format(filter_ip=self.filter_ip,</div><div class="line">                                                                       filter_port=self.filter_port,url=url)</div><div class="line">        <span class="keyword">return</span> self.seaweedfs.delete_file(url_complete)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self,url)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        download a file from seaweedfs</div><div class="line">        :param url:</div><div class="line">        :return:</div><div class="line">            Content of the file with provided url or None if file doesn't</div><div class="line">                exist on the server</div><div class="line">        """</div><div class="line">        url_complete = <span class="string">"http://&#123;filter_ip&#125;:&#123;filter_port&#125;&#123;url&#125;"</span>.format(filter_ip=self.filter_ip,</div><div class="line">                                                                      filter_port=self.filter_port,url=url)</div><div class="line">        <span class="keyword">return</span> self.seaweedfs.get_file(url_complete)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parseURL</span><span class="params">(self,url)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        parse url to account, container, obj_name</div><div class="line">        :param url:</div><div class="line">        :return: account, container, obj_name</div><div class="line">        """</div><div class="line">        url_split = url.split(<span class="string">'/'</span>)</div><div class="line">        <span class="keyword">return</span> url_split[<span class="number">1</span>],url_split[<span class="number">2</span>],url_split[<span class="number">3</span>]</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack-swift源码阅读记录4-启用mem_diskfile]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/openstack-swift%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%954-%E5%90%AF%E7%94%A8mem_diskfile/</url>
      <content type="html"><![CDATA[<p>修改/etc/swift/object-server/中的文件,改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[app:object-server]</div><div class="line">use = egg:swift#mem_object</div></pre></td></tr></table></figure></p>
<p>mem_diskfile为mem_server提供内存存储后端实现,而mem_server继承自server.ObjectController,提供请求转发工作,其中,设置客户端超时时间:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.client_timeout = int(conf.get(&apos;client_timeout&apos;, 60))</div></pre></td></tr></table></figure></p>
<h3 id="用户上传对象过程"><a href="#用户上传对象过程" class="headerlink" title="用户上传对象过程"></a>用户上传对象过程</h3><p>调用mem_diskfile中的put_object方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">def put_object(self, name, fp, metadata):</div></pre></td></tr></table></figure></p>
<p>参数:<br><img src="/uploads/2017-02-25 19-43-22put_object参数.png" alt="mem_diskfile.put_object参数"><br>可以看到,name为account,container,object的组合</p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在Openstack Swift中使用多种后端存储实现]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/%E5%9C%A8Openstack%20Swift%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A7%8D%E5%90%8E%E7%AB%AF%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>在Intel开发者社区发现这篇文章,给我很大的帮助,尝试着把它翻译成中文. 原文链接<a href="https://software.intel.com/en-us/blogs/2015/02/03/using-multiple-backends-in-openstack-swift" target="_blank" rel="external">Using Multiple Backends in Openstack Swift</a></p>
<h1 id="Using-Multiple-Backends-in-Openstack-Swift"><a href="#Using-Multiple-Backends-in-Openstack-Swift" class="headerlink" title="Using Multiple Backends in Openstack Swift"></a>Using Multiple Backends in Openstack Swift</h1><p>By <a href="https://software.intel.com/en-us/user/496209" target="_blank" rel="external">Yuan Zhou (Intel)</a>, Added February 3, 2015</p>
<p>OpenStack Swift是一个高度可用的，分布式的，最终一致的对象存储实现系统. 考虑到经济效益及存储横向扩展能力,对象存储是理想的存储实现模式.它提供了一个完全分布式，API可访问的存储平台，可以直接集成到应用程序中或用于备份，归档和保存数据。有关详细信息，请参阅<a href="http://docs.openstack.org/developer/swift/。" target="_blank" rel="external">http://docs.openstack.org/developer/swift/。</a><br>由于V2.0 Swift支持多个存储策略,这允许通过创建多个object ring来为不同目的进行不同的存储策略,从而实现某种程度的分段集群.对于帐户数据库，容器数据库有一个单独的ring，并且每个存储策略都有一个object ring。通过支持多个对象环，Swift允许应用程序和/或部署程序在单个集群中实现分离对象存储功能。然而Swift拥有另一个相当好的功能:从Juno发行版开始,支持可插拔存储后端. 得益于对象服务器中高度抽象的DiskFile API,存储设备提供商可以轻易地使用不同后端存储实现方案去存储文件对象. 这些项目有几个共同的特征:</p>
<ol>
<li>这些项目被实现为一些新的WSGI对象服务器应用程序。Swift DiskFile抽象是这些多个后端解决方案的引擎.</li>
<li>这些项目正试图利用Swift / S3 API来加入对象存储市场或OpenStack生态系统.</li>
<li>目前这些项目大部分都在POC状态，并且不是很活跃。<h2 id="本地磁盘后端"><a href="#本地磁盘后端" class="headerlink" title="本地磁盘后端"></a>本地磁盘后端</h2>默认情况下，Swift将使用本地磁盘作为对象服务器中的存储设备. 在此实现中，用户上传的文件将单独存储在位于磁盘上层的本地文件系统中. 元数据将与文件一起存储为文件的扩展属性. 这需要一个支持文件扩展属性的文件系统，如xfs或ext4.<br><img src="/uploads/swift-multibackend-01.jpg" alt=""><br>对象服务器中的DiskFile API是一组RESTFul接口,如READ，WRITE和DELETE. 在这个本地磁盘后端，这些接口大多数是用POSIX API实现的. 例如，WRITE请求将调用python中的os.write().<br><img src="/uploads/swift-multibackend-02.jpg" alt=""><br>要使用此后端，您只需要复制示例object-server.conf. 注意，默认的WSGI应用程序应该是:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[app:object-server]</div><div class="line"></div><div class="line">use = egg: swift#object</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其他后端解决方案需要使用自己的接口来实现这些接口.</p>
<h2 id="使用内存后端"><a href="#使用内存后端" class="headerlink" title="使用内存后端"></a>使用内存后端</h2><p>这是在Swift中的样本示例. 在此实现中，用户上传的文件将与其元数据一起存储在内存的散列表(python dict)中. 每个键是accout，container和object_name的组合,相应的值是对象及其元数据的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filesystem[name] = &#123;data, metadata&#125;</div></pre></td></tr></table></figure></p>
<p>在DiskFile的一个PUT请求将是一个简单的python dict更新,这个解决方案目前只是一个原型，不适合在生产环境中使用. 我们可以很轻易地知道,当对象服务器关闭,所有的数据都会丢失.<br><img src="/uploads/swift-multibackend-03.jpg" alt=""><br>要使用此后端，您需要将object-server.conf中的默认WSGI应用程序更改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[app:object-server]</div><div class="line">use = egg: swift#mem_object</div></pre></td></tr></table></figure></p>
<p>然后重新启动对象服务器.</p>
<h2 id="Swift-Ceph后端"><a href="#Swift-Ceph后端" class="headerlink" title="Swift-Ceph后端"></a>Swift-Ceph后端</h2><p>目前这是一个由eNovance发起的stackforge项目.这个实现使用Ceph作为Swift的存储设备. Swift对象环被配置为1x副本，而Ceph可以配置为3x副本. 这意味着从Swift的视图，只有1个对象副本存储在集群中。但是在Ceph集群中，将有3个对象的副本，并且Ceph将做一致性/复制工作.一般设计是来自DiskFile的新派生类，它将Swift读/写转换为使用librados读/写rados对象. Swift中的一个对象将被存储为Ceph中的一个文件，其名称为account，container和object name的组合.目前,account/container数据库依然以原始的方式存储在Swift当中.该项目还有一个计划，以便以后将这些SQLite DB存储到Ceph.<br><img src="/uploads/swift-multibackend-04-new.png" alt=""><br>此解决方案实现为WSGI应用程序,要使用此后端，您需要安装swift-ceph-backend项目，并将object-server.conf中的默认WSGI应用程序更改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[app:object-server]</div><div class="line">use = egg: swift_ceph_backend#rados_object</div></pre></td></tr></table></figure></p>
<p>然后重新启动对象服务器.</p>
<h2 id="Swift-On-File后端"><a href="#Swift-On-File后端" class="headerlink" title="Swift-On-File后端"></a>Swift-On-File后端</h2><p>Swift-on-File项目也是由Redhat发起的stackforge项目, 目前它是一个Swift对象服务器的实现, 它使用户能够访问相同的数据，既作为对象也可作为文件. 数据可以通过Swift的REST接口存储和检索，也可作为NAS接口的文件，包括本地GlusterFS，NFS和CIFS.<br><img src="/uploads/swift-multibackend-05.jpg" alt=""><br>要使用此后端，您需要安装swiftonfile项目，然后将object-server.conf中的默认WSGI应用程序更改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[app:object-server]</div><div class="line">use = egg:swiftonfile#object</div></pre></td></tr></table></figure></p>
<p>您还需要在/mnt/swiftonfile 挂载一个NFS分区,或GlusterFS卷<br>建议将对象环配置为仅1个副本. 所有的一致性/复制工作都在GlusterFS / NFS层中处理</p>
<h2 id="Seagate-kinetics后端"><a href="#Seagate-kinetics后端" class="headerlink" title="Seagate kinetics后端"></a>Seagate kinetics后端</h2><p>Swift over Seagate 是由SwiftStack和Seagate开始的一个项目. 目前，它仍然在试验beta Kinetic库中. 使用Kinetic驱动器的Swift群集允许访问任何驱动器，从而访问任何对象.对于当前的Kinetic集成,对象服务器命令（对象守护程序）的一小部分被嵌入在作为逻辑构造的代理服务器中,如下所示:<br><img src="/uploads/swift-multibackend-06.jpg" alt=""><br>还有一些通过kinetic部署的设备,由于这个项目仍在开发中,没有准备过多的文档. 您需要检查最新的代码来了解详细信息.</p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="http://docs.openstack.org/developer/swift/" target="_blank" rel="external">http://docs.openstack.org/developer/swift/</a><br><a href="https://swiftstack.com/blog/2014/02/04/swift-extensibility/" target="_blank" rel="external">https://swiftstack.com/blog/2014/02/04/swift-extensibility/</a><br><a href="https://github.com/stackforge/swift-ceph-backend" target="_blank" rel="external">https://github.com/stackforge/swift-ceph-backend</a><br><a href="https://github.com/stackforge/swiftonfile" target="_blank" rel="external">https://github.com/stackforge/swiftonfile</a><br><a href="https://github.com/swiftstack/kinetic-swift" target="_blank" rel="external">https://github.com/swiftstack/kinetic-swift</a><br><a href="https://developers.seagate.com/display/KV/OpenStack+Swift" target="_blank" rel="external">https://developers.seagate.com/display/KV/OpenStack+Swift</a></p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack-swift源码阅读记录3-diskfile]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/openstack-swift%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%953-diskfile/</url>
      <content type="html"><![CDATA[<p>diskfile模块：<br>diskfile模块为Swift对象服务器的磁盘文件接口</p>
<p>“DiskFile”，“DiskFileWriter”和“DiskFileReader”类组合定义用于支持对象服务器REST API的磁盘抽象层接口（不包括<code>REPLICATE</code>）。 其他希望提供的实现对象服务器的替代后端必须实现三个类。 <code>mem_server.py</code>和<code>mem_diskfile.py</code>模块为其中的一个实现示例。</p>
<p><code>DiskFileManager</code>是一个参考实现特定的类，而不是部分后端API。</p>
<p>此模块中的其余方法被视为具体实现并且也不被视为后端API的一部分。</p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu使用问题总结]]></title>
      <url>https://makeitpossible16.github.io/ubuntu/ubuntu%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="lightdm登录界面找不到登录用户名"><a href="#lightdm登录界面找不到登录用户名" class="headerlink" title="lightdm登录界面找不到登录用户名"></a>lightdm登录界面找不到登录用户名</h2><p>问题分析：直接修改/etc/passwd文件中的用户user id，想要用此方法提升普通用户权限为root权限，但把user id在/etc/passwd中重新改成不为原有user id（比如原有user id 为1000，改成0后，又改成1001）时，会导致系统找不到用户，这是再改成1000，系统也会找不到用户，因此在登录界面不显示。<br>解决方法：使用userdel 删除用户，但不删除与用户相关配置文件，然后使用useradd添加同名用户，即可在登录页面显示。</p>
<h2 id="系统登录不断循环"><a href="#系统登录不断循环" class="headerlink" title="系统登录不断循环"></a>系统登录不断循环</h2><p>问题分析：参考<a href="http://www.tuicool.com/articles/IBreErY" target="_blank" rel="external">Ubuntu 14.04登陆界面无限循环的解决办法</a>,其中提到，home目录空间满了，还有一种可能是：由于添加了同名用户，但用户的user id不一样，系统认为/home目录不属于当前登录用户，导致登录不进去。<br>解决方法：常看当前用户的user id：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id -u &lt;username&gt;</div></pre></td></tr></table></figure></p>
<p>使用ll命令查看当前用户的/home文件夹所有者的user id是否为当前用户的user id，如果不是，使用命令chown改变home目录的所有者。</p>
<h2 id="无法执行-bin-bash，没有那个文件或目录"><a href="#无法执行-bin-bash，没有那个文件或目录" class="headerlink" title="无法执行/bin/bash，没有那个文件或目录"></a>无法执行/bin/bash，没有那个文件或目录</h2><p><img src="/uploads/2017-02-16 19-46-51.png" alt=""><br>问题分析：参考<a href="https://my.oschina.net/u/2324376/blog/388412" target="_blank" rel="external">脚本格式之殇——/bin/bash^M: 没有那个文件或目录</a> ，修改过/etc/passwd文件，导致/bin/bash后面多加空格符<br>解决方法：使用cat -A filename查看文件，把不规则的空格去掉</p>
]]></content>
      
        <categories>
            
            <category> ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack源码阅读记录2-object metadata]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/openstack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%952-object%20metadata/</url>
      <content type="html"><![CDATA[<p>通过调试,得到object metadata的格式:<br><img src="/uploads/2017-02-13 16-28-30.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack-swift源码阅读记录1-文件上传过程]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/openstack-swift%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%951-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>使用命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swift upload</div></pre></td></tr></table></figure></p>
<p>上传文件,openstack-swift调用过程<br><img src="/uploads/2017-02-13 12-41-40.png" alt=""></p>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HEAD</span><span class="params">(self, request)</span>:</span></div><div class="line">        <span class="string">"""Handle HTTP HEAD requests for the Swift Object Server."""</span></div><div class="line">        device, partition, account, container, obj, policy = \</div><div class="line">            get_name_and_placement(request, <span class="number">5</span>, <span class="number">5</span>, <span class="keyword">True</span>)</div><div class="line">            <span class="comment">#从请求中获取相应信息,其中:</span></div><div class="line">            <span class="comment">#policy:根据request中的X-Backend-Storage-Policy-Index获得</span></div><div class="line">            <span class="comment">#device, partition, account, container, obj根据request.path获得</span></div><div class="line">        frag_prefs = safe_json_loads(</div><div class="line">            request.headers.get(<span class="string">'X-Backend-Fragment-Preferences'</span>))</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            disk_file = self.get_diskfile(</div><div class="line">                device, partition, account, container, obj,</div><div class="line">                policy=policy, frag_prefs=frag_prefs)</div><div class="line">                <span class="comment"># disk_file:BaseDiskFile对象</span></div><div class="line">        <span class="keyword">except</span> DiskFileDeviceUnavailable:</div><div class="line">            <span class="keyword">return</span> HTTPInsufficientStorage(drive=device, request=request)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            metadata = disk_file.read_metadata()</div><div class="line">            <span class="comment">#从object中读取metadata</span></div><div class="line">        <span class="keyword">except</span> DiskFileXattrNotSupported:</div><div class="line">            <span class="keyword">return</span> HTTPInsufficientStorage(drive=device, request=request)</div><div class="line">        <span class="keyword">except</span> (DiskFileNotExist, DiskFileQuarantined) <span class="keyword">as</span> e:</div><div class="line">            headers = &#123;&#125;</div><div class="line">            <span class="keyword">if</span> hasattr(e, <span class="string">'timestamp'</span>):</div><div class="line">                headers[<span class="string">'X-Backend-Timestamp'</span>] = e.timestamp.internal</div><div class="line">            <span class="keyword">return</span> HTTPNotFound(request=request, headers=headers,</div><div class="line">                                conditional_response=<span class="keyword">True</span>)</div><div class="line">        conditional_etag = resolve_etag_is_at_header(request, metadata)</div><div class="line">        response = Response(request=request, conditional_response=<span class="keyword">True</span>,</div><div class="line">                            conditional_etag=conditional_etag)</div><div class="line">        response.headers[<span class="string">'Content-Type'</span>] = metadata.get(</div><div class="line">            <span class="string">'Content-Type'</span>, <span class="string">'application/octet-stream'</span>)</div><div class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> metadata.items():</div><div class="line">            <span class="keyword">if</span> (is_sys_or_user_meta(<span class="string">'object'</span>, key) <span class="keyword">or</span></div><div class="line">                    is_object_transient_sysmeta(key) <span class="keyword">or</span></div><div class="line">                    key.lower() <span class="keyword">in</span> self.allowed_headers):</div><div class="line">                response.headers[key] = value</div><div class="line">        response.etag = metadata[<span class="string">'ETag'</span>]</div><div class="line">        ts = Timestamp(metadata[<span class="string">'X-Timestamp'</span>])</div><div class="line">        response.last_modified = math.ceil(float(ts))</div><div class="line">        <span class="comment"># Needed for container sync feature</span></div><div class="line">        response.headers[<span class="string">'X-Timestamp'</span>] = ts.normal</div><div class="line">        response.headers[<span class="string">'X-Backend-Timestamp'</span>] = ts.internal</div><div class="line">        response.headers[<span class="string">'X-Backend-Data-Timestamp'</span>] = \</div><div class="line">            disk_file.data_timestamp.internal</div><div class="line">        <span class="keyword">if</span> disk_file.durable_timestamp:</div><div class="line">            response.headers[<span class="string">'X-Backend-Durable-Timestamp'</span>] = \</div><div class="line">                disk_file.durable_timestamp.internal</div><div class="line">        response.headers[<span class="string">'X-Backend-Fragments'</span>] = \</div><div class="line">            _make_backend_fragments_header(disk_file.fragments)</div><div class="line">        response.content_length = int(metadata[<span class="string">'Content-Length'</span>])</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            response.content_encoding = metadata[<span class="string">'Content-Encoding'</span>]</div><div class="line">        <span class="keyword">except</span> KeyError:</div><div class="line">            <span class="keyword">pass</span></div><div class="line">        <span class="keyword">return</span> response</div></pre></td></tr></table></figure>
<h2 id="获取diskfile过程"><a href="#获取diskfile过程" class="headerlink" title="获取diskfile过程"></a>获取diskfile过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># obj/server.py 中的get_diskfile,通过BaseDiskFileManager中的get_diskfile方法,返回BaseDiskFile对象</span></div><div class="line"></div><div class="line"><span class="comment"># get_diskfile返回BaseDiskFile对象</span></div><div class="line"><span class="keyword">return</span> self.diskfile_cls(self, dev_path,</div><div class="line">                         partition, account, container, obj,</div><div class="line">                         policy=policy, use_splice=self.use_splice,</div><div class="line">                         pipe_size=self.pipe_size,</div><div class="line">                         use_linkat=self.use_linkat, **kwargs)  <span class="comment"># diskfile_cls : BaseDiskFile</span></div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件合并存储与单个存储优劣势分析]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(seaweedfs)%E4%B8%8E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8A%A3%E5%8A%BF%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><p>经过一段时间的学习，想要把openstack-swift与seaweedfs进行结合，单纯考虑文件存储效率，对比把openstack-swift与seaweedfs进行结合后的存储效率是否会高于openstack-swift.问题最后可以简化为文件合并存储与单个存储优劣势比较.</p>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="文件单个存储"><a href="#文件单个存储" class="headerlink" title="文件单个存储"></a>文件单个存储</h3><p>从Linux内核文件系统出发,以ext3为例,参考<a href="http://www.cnblogs.com/zengyiwen/p/5755186.html" target="_blank" rel="external">深入解析Linux内核I/O剖析（open,write实现）</a>,<a href="http://book.2cto.com/201312/38238.html" target="_blank" rel="external">do_filp_open函数</a>,<a href="http://alanwu.blog.51cto.com/3652632/1106506/" target="_blank" rel="external">Ext3文件系统读写过程分析</a>当用户执行文件读写操作时,首先需要open相应的文件，然后再进行读写操作。在open操作时，首先将用户空间的文件名参数复制到内核空间,Linux kernel会执行do_filp_open函数,在do_filp_open函数中,沿着要打开文件名的整个路径，一层层解析路径，最后得到文件的dentry和vfsmount对象，保存到一个nameidata结构中,根据获得的nameidata结构，初始化一个file对象描述这个文件,File对象和文件的dentry和inode对象建立联系，并且将ext3的文件操作方法、映射处理方法（address space）注册到file对象中。<br>File数据结构是Linux用来描述文件的关键数据结构，该对象在一个文件被进程打开的时候被创建。当一个文件被关闭的时候，file对象也会被立即销毁。<br>执行open的最终结果:将文件描述符fd与文件管理结构file对应起来</p>
<h3 id="文件合并存储"><a href="#文件合并存储" class="headerlink" title="文件合并存储"></a>文件合并存储</h3><p>文件读写是,若文件没有关闭,只需进行一次open操作,直接以lseek为例,参考<a href="http://linux.chinaunix.net/techdoc/system/2009/04/30/1109611.shtml" target="_blank" rel="external">linux内核文件IO的系统调用实现分析(flseek&amp;close)</a>,使用lseek,设置文件开始读取的位置,当调用read或write时直接从该位置读取数据.</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><table>
<thead>
<tr>
<th style="text-align:left">存储方式</th>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">文件单个存储</td>
<td>存储过程简单,进行读写时直接进行读取,不需要进行lseek</td>
<td>容易产生页面空洞,导致磁盘扇区利用率降低,大量的文件,会增加文件系统需要维护的inode及dentry,降低文件存储效率.</td>
</tr>
<tr>
<td style="text-align:left">合并存储</td>
<td>多个文件合并存储,减少文件系统需要维护的inode及dentry,文件连续写入,提高扇区利用率</td>
<td>文件读写时,需要进行lseek,增加文件偏移量查找操作</td>
</tr>
</tbody>
</table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于大规模存储系统,若能把大文件与小文件进行分开存储,大文件采用单文件存储,小文件使用合并存储,理论上可以提高系统存储效率.可以把openstack-swift与seaweedfs的存储部分进行结合,优化openstack-swift对象存储效率.</p>
]]></content>
      
        <categories>
            
            <category> 文件系统 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> seaweedfs </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构]]></title>
      <url>https://makeitpossible16.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p><a href="http://blog.csdn.net/fansongy/article/details/6798278/" target="_blank" rel="external">数据结构（六）——二叉树 前序、中序、后序、层次遍历及非递归实现 查找、统计个数、比较、求深度的递归实现</a><br>前序遍历：根节点-&gt;左子树-&gt;右子树<br>中序遍历：左子树-&gt;根节点-&gt;右子树<br>后序遍历：左子树-&gt;右子树-&gt;根节点</p>
<h2 id="简单清晰的B树、Trie树详解"><a href="#简单清晰的B树、Trie树详解" class="headerlink" title="简单清晰的B树、Trie树详解"></a>简单清晰的B树、Trie树详解</h2><p><a href="http://blog.csdn.net/yang_yulei/article/details/26104921" target="_blank" rel="external">简单清晰的B树、Trie树详解</a></p>
<h2 id="跳表-SkipList"><a href="#跳表-SkipList" class="headerlink" title="跳表 SkipList"></a>跳表 SkipList</h2><p>在leveldb、redis中, 为了提高数据的查找效率,使用了SkipList,参考<a href="http://blog.sina.com.cn/s/blog_72995dcc01017w1t.html" target="_blank" rel="external">SkipList跳表基本原理</a>, <a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html" target="_blank" rel="external">跳表SkipList</a></p>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python语法记录]]></title>
      <url>https://makeitpossible16.github.io/python%E8%AF%AD%E6%B3%95/python%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>记录一下忘记的Python语法</p>
<h2 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h2><p>负责在内存中读写string,其中在openstack-swift的mem_diskfile.py中提到::param fp: <code>StringIO</code> in-memory representation object<br><a href="StringIO和BytesIO">StringIO和BytesIO</a></p>
<h2 id="os-fstat"><a href="#os-fstat" class="headerlink" title="os.fstat()"></a>os.fstat()</h2><p>os.fstat() 方法用于返回文件描述符fd的状态，类似 stat()。<br><a href="http://www.runoob.com/python/os-fstat.html" target="_blank" rel="external">Python os.fstat() 方法</a></p>
<h2 id="struct-pack"><a href="#struct-pack" class="headerlink" title="struct.pack"></a>struct.pack</h2><p>参考<a href="http://blog.sina.com.cn/s/blog_71f389090100zkp1.html" target="_blank" rel="external">Python学习——struct模块的pack、unpack示例</a><br>struct.pack用于将Python的值根据格式符，转换为字符串（因为Python中没有字节 (Byte)类型，可以把这里的字符串理解为字节流，或字节数组）。其函数原型为：struct.pack(fmt, v1, v2, …)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import struct  </div><div class="line">a = 20</div><div class="line">b = 400</div><div class="line">str = struct.pack(&quot;ii&quot;, a, b)  # /x14/x00/x00/x00/x90/x01/x00/x00</div></pre></td></tr></table></figure></p>
<p>转换后的str虽然是字符串类型，但相当于其他语言中的字节流（字节数组），可以在网络上传输.<br>格式符”i”表示转换为int，’ii’表示有两个int变量。进行转换后的结果长度为8个字节（int类型占用4个字节，两个int为8个字 节），可以看到输出的结果是乱码，因为结果是二进制数据，所以显示为乱码。可以使用python的内置函数repr来获取可识别的字符串，其中十六进制的 0x00000014, 0x00001009分别表示20和400。</p>
<h2 id="struct-unpack"><a href="#struct-unpack" class="headerlink" title="struct.unpack"></a>struct.unpack</h2><p>struct.unpack做的工作刚好与struct.pack相反，用于将字节流转换成python数 据类型。它的函数原型为：struct.unpack(fmt, string)，该函数返回一个元组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct.pack(&quot;ii&quot;, 20, 400)  </div><div class="line">a1, a2 = struct.unpack(&quot;ii&quot;, str)  </div><div class="line">print &apos;a1:&apos;, a1  </div><div class="line">print &apos;a2:&apos;, a2  </div><div class="line"></div><div class="line">#---- result:  </div><div class="line">#a1: 20  </div><div class="line">#a2: 400</div></pre></td></tr></table></figure></p>
<h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>参考<a href="http://www.cnblogs.com/itdyb/p/5046415.html" target="_blank" rel="external">Python中的repr()函数</a><br>Python 有办法将任意值转为字符串：将它传入repr() 或str() 函数。<br>函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式。<br>repr（）函数得到的字符串通常可以用来重新获得该对象，repr（）的输入对python比较友好。通常情况下obj==eval(repr(obj))这个等式是成立的。</p>
<h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h2><p>参考<a href="http://blog.csdn.net/churximi/article/details/51648388" target="_blank" rel="external">python enumerate用法总结</a><br>如果对一个列表，既要遍历索引又要遍历元素时,可利用enumerate.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list1 = [<span class="string">"这"</span>, <span class="string">"是"</span>, <span class="string">"一个"</span>, <span class="string">"测试"</span>]</div><div class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(list1):</div><div class="line">    <span class="keyword">print</span> index, item</div></pre></td></tr></table></figure></p>
<p>还可以接收第二个参数，用于指定索引起始值.<br>要统计文件的行数，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">count = -1</div><div class="line">for index, line in enumerate(open(filepath,&apos;r&apos;))：</div><div class="line">    count += 1</div></pre></td></tr></table></figure></p>
<h2 id="decorator"><a href="#decorator" class="headerlink" title="@ decorator"></a>@ decorator</h2><p>这个符号用于装饰器中，用于修饰一个函数，把被修饰的函数作为参数传递给装饰器，参考<a href="http://www.cnblogs.com/baibai-tech/p/4035488.html" target="_blank" rel="external">Python的@符号</a><br>@classmethod和@staticmethod<br>这两个含义很明显，在定义方法的时候@classmethod表示该方法是类方法,类方法必须有一个参数为cls,表示类本身，实例方法的第一个参数是self.@staticmethod修饰的方法基本上和一个全局函数相同。<br>这两个修饰的方法通过实例和类调用都是可以的</p>
]]></content>
      
        <categories>
            
            <category> python语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu16.04搭建openstack-swift单机开发环境]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/ubuntu16.04%E6%90%AD%E5%BB%BAopenstack-swift%E5%8D%95%E6%9C%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>使用虚拟机进行远程调试电脑太卡，用着不爽，所以搭建单机板环境，按照<a href="http://docs.openstack.org/developer/swift/development_saio.html" target="_blank" rel="external">SAIO</a>搭建,在Ubuntu14.04上搭建没有啥问题，但在Ubuntu16.04上会出现问题，记录一下。</p>
<h2 id="出现问题1"><a href="#出现问题1" class="headerlink" title="出现问题1"></a>出现问题1</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"/usr/local/bin/swift-object-server"</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="built_in">exec</span>(compile(open(__file__).read(), __file__, <span class="string">'exec'</span>))</div><div class="line">  File <span class="string">"/home/ubuntu/swift/bin/swift-object-server"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    from swift.common.wsgi import run_wsgi</div><div class="line">  File <span class="string">"/home/ubuntu/swift/swift/common/wsgi.py"</span>, line 41, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    from swift.common.storage_policy import BindPortsCache</div><div class="line">  File <span class="string">"/home/ubuntu/swift/swift/common/storage_policy.py"</span>, line 25, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    from pyeclib.ec_iface import ECDriver, ECDriverError, VALID_EC_TYPES</div><div class="line">  File <span class="string">"/usr/local/lib/python2.7/dist-packages/pyeclib/ec_iface.py"</span>, line 29, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    from pyeclib_c import check_backend_available</div><div class="line">ImportError: /usr/<span class="built_in">local</span>/lib/python2.7/dist-packages/pyeclib_c.so: undefined symbol: liberasurecode_backend_available</div></pre></td></tr></table></figure>
<p>系统找不到liberasurecode_backend_available。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>参考<a href="https://ask.openstack.org/en/question/93267/unable-to-start-swift-proxy-liberasurecode-missing-libshssso/" target="_blank" rel="external">openstack-swift bug反馈</a>，得到解决方法:<br>根据Alex Usov 的回答：<br>Finally got it working. Had to compile liberasurecode from <a href="https://github.com/openstack/liberasurecode.git" target="_blank" rel="external">https://github.com/openstack/liberasurecode.git</a> (<a href="https://github.com/openstack/liberasu" target="_blank" rel="external">https://github.com/openstack/liberasu</a>…), add line /usr/local/lib to /etc/ld.so.conf, run ldconfig, and restart openstack-swift-proxy.</p>
<p>具体操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> https://github.com/openstack/liberasurecode.git</div><div class="line">$ <span class="built_in">cd</span> liberasurecode</div><div class="line">$ ./autogen.sh</div><div class="line">$ ./configure</div><div class="line">$ make</div><div class="line">$ make <span class="built_in">test</span></div><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p>
<p>在 /etc/ld.so.conf中添加一行：/usr/local/lib<br>运行 ldconfig</p>
<h2 id="创建container失败"><a href="#创建container失败" class="headerlink" title="创建container失败"></a>创建container失败</h2><p>错误提示: 404<br>Container PUT failed: <a href="http://127.0.0.1:8080/v1/AUTH_test/test" target="_blank" rel="external">http://127.0.0.1:8080/v1/AUTH_test/test</a> 404 Not Found  [first 60 chars of response] <html><h1>Not Found</h1><p>The resource could not be found.</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>参考<a href="https://answers.launchpad.net/swift/+question/235980" target="_blank" rel="external">unable to create containers</a><br>错误出现原因: 删除了相关存储文件夹,即/mnt/sdb1 或 /srv 中相关文件夹,按照<a href="http://docs.openstack.org/developer/swift/development_saio.html" target="_blank" rel="external">SAIO - Swift All In One</a>重新搭建环境即可</p>
<h2 id="502-Server-dropped-connection"><a href="#502-Server-dropped-connection" class="headerlink" title="502 Server dropped connection"></a>502 Server dropped connection</h2><p>发起请求时出现502错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ swift stat</div><div class="line">Auth GET failed: http://127.0.0.1:8080/auth/v1.0 502 Server dropped connection  [first 60 chars of response] &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//E</div></pre></td></tr></table></figure></p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法:"></a>解决方法:</h3><p>把代理关掉</p>
</html></p>]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[openstack-swift调试]]></title>
      <url>https://makeitpossible16.github.io/%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/openstack-swift%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>最近在学习openstack-swift的源码，想通过调试的方式弄清楚它的运行方式，记录一下，提高一下效率。</p>
<h2 id="启用调试"><a href="#启用调试" class="headerlink" title="启用调试"></a>启用调试</h2><p>按照swift all in one的方式搭建，没遇到啥问题。<br>调试的方案有两种（都支持远程调试），一种是采用pydev,这种方式需要禁用swift的多线程；另一种采用winpdb，这种方式支持多线程。<br>禁用多线程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eventlet.patcher.monkey_patch(all=<span class="keyword">False</span>, socket=<span class="keyword">True</span>, time=<span class="keyword">True</span>, thread=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p>
<h3 id="使用pydevd调试"><a href="#使用pydevd调试" class="headerlink" title="使用pydevd调试"></a>使用pydevd调试</h3><p> 我主要采用pycharm + pydevd + NFS的方式远程调试，具体操作参照这两篇文章：<a href="http://yikun.github.io/2016/02/23/%E4%BC%98%E9%9B%85%E5%9C%B0%E8%B0%83%E8%AF%95OpenStack/#4-_启动调试服务器" target="_blank" rel="external">openstack调试</a><br><a href="http://debugopenstack.blogspot.com.tr/" target="_blank" rel="external">远程调试</a><br>其实只要使用NFS把代码挂载到本地，在pycharm中设置远程调试，代码中加入断点即可。加入断点代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import pydevd</div><div class="line">pydevd.settrace(&lt;pycharm所在机子IP&gt;, 设置端口, stdoutToServer=True, stderrToServer=True)</div></pre></td></tr></table></figure>
<h3 id="使用winpdb调试"><a href="#使用winpdb调试" class="headerlink" title="使用winpdb调试"></a>使用winpdb调试</h3><p>在代码中加入断点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import rpdb2</div><div class="line">rpdb2.start_embedded_debugger(&apos;12345&apos;,fAllowRemote=True)</div></pre></td></tr></table></figure>
<p>start_embedded_debugger第一个参数为密码，在winpdb中attach时输入，第二个参数启用远程调试，启用远程调试时，在远程调试的机子上启动winpdb，attach时输入密码，并输入swift部署机子IP即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我喜欢用方式一，可以把调试的信息直接标注在代码旁。方式二支持分布式调试，但太轻量化，只能看，不能添加，各有优缺点，按需选择。<br>修改代码后需要重启swift才能生效。<br>调试记录信息会放到github上，<a href="https://github.com/MakeItPossible16/openstack-swift" target="_blank" rel="external">github地址</a></p>
]]></content>
      
        <categories>
            
            <category> 对象存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> openstack-swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux文件存储机制]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/linux%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cache/" target="_blank" rel="external">Linux 内核的文件 Cache 管理机制介绍</a><br><a href="http://www.cnblogs.com/huxiao-tee/p/4657851.html" target="_blank" rel="external">从内核文件系统看文件读写过程</a></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 文件存储 </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kafka学习笔记]]></title>
      <url>https://makeitpossible16.github.io/kafka/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h2><p><a href="http://www.orchome.com/5" target="_blank" rel="external">kafka入门介绍</a></p>
<h2 id="学习目的"><a href="#学习目的" class="headerlink" title="学习目的"></a>学习目的</h2><p>构建日志流处理系统，初步实现使用logstash进行日志采集，kafka作为缓存队列，flink进行实时数据分析处理，seaweedfs作为后端存储。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="核心API类型"><a href="#核心API类型" class="headerlink" title="核心API类型"></a>核心API类型</h3><p>应用程序使用 Producer API 发布消息到1个或多个topic（主题）。<br>应用程序使用 Consumer API 来订阅一个或多个topic，并处理产生的消息。<br>应用程序使用 Streams API 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。<br>Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。</p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p>Topic<br>  Kafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic).<br>Producer<br>  发布消息的对象称之为主题生产者(Kafka topic producer)<br>Consumer<br>  订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)<br>Broker<br>  已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</p>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。</p>
<h3 id="kafka有比传统的消息系统更强的顺序保证"><a href="#kafka有比传统的消息系统更强的顺序保证" class="headerlink" title="kafka有比传统的消息系统更强的顺序保证"></a>kafka有比传统的消息系统更强的顺序保证</h3><p>如果多个消费者从队列消费，则服务器按存储的顺序发送消息，但是，尽管服务器按顺序发送，消息异步传递到消费者，因此消息可能乱序到达消费者。<br>kafka通过并行topic的parition —— kafka提供了顺序保证和负载均衡。每个partition仅由同一个消费者组中的一个消费者消费到。并确保消费者是该partition的唯一消费者，并按顺序消费数据。每个topic有多个分区，则需要对多个消费者做负载均衡，但请注意，相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息。</p>
<h3 id="kafka可作为存储系统"><a href="#kafka可作为存储系统" class="headerlink" title="kafka可作为存储系统"></a>kafka可作为存储系统</h3>]]></content>
      
        <categories>
            
            <category> kafka </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux内核学习-数据结构]]></title>
      <url>https://makeitpossible16.github.io/linux%E5%86%85%E6%A0%B8/linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="container-of"><a href="#container-of" class="headerlink" title="container_of"></a>container_of</h2><p>用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。<br><a href="http://blog.csdn.net/npy_lp/article/details/7010752" target="_blank" rel="external">Linux内核中的常用宏container_of其实很简单</a></p>
<h2 id="linux内核Hash-链表"><a href="#linux内核Hash-链表" class="headerlink" title="linux内核Hash 链表"></a>linux内核Hash 链表</h2><p><a href="http://blog.csdn.net/tigerjibo/article/details/8450995" target="_blank" rel="external">Linux内核哈希表分析与应用</a></p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>应用:<br>有一个庞大的字符串数组，然后给你一个单独的字符串，让你从这个数组中查找是否有这个字符串并找到它<br><a href="http://blog.csdn.net/shanzhizi/article/details/7736526#comments" target="_blank" rel="external">暴雪公司关于字符串匹配的hash算法</a></p>
<p>典型的应用场景(Hbase，Accumulo，Leveldb)：<br>某些存储系统的设计中，会存在空查询缺陷：当查询一个不存在的key时，需要访问慢设备，导致效率低下。<br>比如一个前端页面的缓存系统，可能这样设计：先查询某个页面在本地是否存在，如果存在就直接返回，如果不存在，就从后端获取。但是当频繁从缓存系统查询一个页面时，缓存系统将会频繁请求后端，把压力导入后端。<br>这是只要增加一个bloom算法的服务，后端插入一个key时，在这个服务中设置一次<br>需要查询后端时，先判断key在后端是否存在，这样就能避免后端的压力。<br><a href="http://www.cnblogs.com/liyulong1982/p/6013002.html" target="_blank" rel="external">布隆过滤器(Bloom Filter)详解</a><br><a href="http://blog.csdn.net/alps1992/article/details/44610587" target="_blank" rel="external">算法学习 - Bloom Filter(布隆过滤器)学习实现(C++实现)</a></p>
<h2 id="RadixTree（基数树）"><a href="#RadixTree（基数树）" class="headerlink" title="RadixTree（基数树）"></a>RadixTree（基数树）</h2><p>应用：Linux radix树最广泛的用途是用于内存管理，结构address_space通过radix树跟踪绑定到地址映射上的核心页，该radix树允许内存管理代码快速查找标识为dirty或writeback的页。其使用的是数据类型unsigned long的固定长度输入的版本。每级代表了输入空间固定位数。Linux radix树的API函数在lib/radix-tree.c中实现。（把页指针和描述页状态的结构映射起来，使能快速查询一个页的信息。）<br><a href="http://blog.csdn.net/yang_yulei/article/details/46371975" target="_blank" rel="external">RadixTree（基数树）</a></p>
]]></content>
      
        <categories>
            
            <category> linux内核 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内核 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ELKStack搭建问题总结]]></title>
      <url>https://makeitpossible16.github.io/ELKStack/ELKStack%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>使用Docker搭建ELKStack时,elasticsearch自动退出,使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker logs [dockerName]</div></pre></td></tr></table></figure></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>查看日志, 日志输出为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ERROR: bootstrap checks failed</div><div class="line">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</div></pre></td></tr></table></figure></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><a href="max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]">Elasticsearch5.0 安装问题集锦</a></p>
<p>切换到root用户修改配置sysctl.conf</p>
<p>vi /etc/sysctl.conf</p>
<p>添加下面配置：</p>
<p>vm.max_map_count=655360</p>
<p>并执行命令：</p>
<p>sysctl -p</p>
<p>然后，重新启动elasticsearch，即可启动成功。</p>
]]></content>
      
        <categories>
            
            <category> ELKStack </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ELKStack </tag>
            
            <tag> 日志分析 </tag>
            
            <tag> 流处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux命令学习]]></title>
      <url>https://makeitpossible16.github.io/linux%E5%91%BD%E4%BB%A4/linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>虽然使用linux有很长一段时间,但对于一些平时用不到的命令,还是比较生疏,记录一下</p>
<h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>AWK是一种处理文本文件的语言，是一个强大的文本分析工具。<br><a href="http://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="external">awk使用介绍</a><br><a href="http://blog.csdn.net/andyxm/article/details/5964071" target="_blank" rel="external">awk print 学习</a></p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>用于排序<br><a href="http://www.cnblogs.com/dong008259/archive/2011/12/08/2281214.html" target="_blank" rel="external">linux之sort用法</a></p>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>报告或删除文件中重复的行。<br><a href="http://blog.csdn.net/jesseen/article/details/8005056" target="_blank" rel="external">linux uniq 命令详解</a></p>
<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p>读取标准输入的数据，并将其内容输出成文件<br><a href="http://liubin.blog.51cto.com/282313/131298" target="_blank" rel="external">linux tee 命令详解</a></p>
<h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p>可以把/dev/null看作一个”黑洞”，它非常等价于一个只写文件，所有写入它的内容都会永远丢失。<br><a href="http://www.2cto.com/os/201412/361275.html" target="_blank" rel="external">linux下/dev/null的用途</a><br><a href="http://blog.csdn.net/sunrier/article/details/7695839/" target="_blank" rel="external">Linux下” &gt;/dev/null 2&gt;&amp;1 “相关知识说明</a></p>
<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>程序后台运行,如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令.<br>命令格式 : nohup command &amp;<br><a href="http://www.2cto.com/os/201301/185701.html" target="_blank" rel="external">linux nohup命令详解</a></p>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>screen 算是 linux 运维一个中高级技巧。通过 screen 命令创建的环境下运行的终端命令，其父进程不是 sshd 登录会话，而是 screen 。这样就可以即避免用户退出进程消失的问题，又随时能重新接管回终端继续操作。<br>创建独立的 screen 命令如下：<br>screen -dmS elkscreen_1<br>接管连入创建的 elkscreen_1 命令如下：<br>screen -r elkscreen_1<br>然后你可以看到一个一模一样的终端，运行 logstash 之后，不要按 Ctrl+C，而是按 Ctrl+A+D 键，断开环境。想重新接管，依然 screen -r elkscreen_1 即可。<br>如果创建了多个 screen，查看列表命令如下：<br>screen -list<br><a href="http://kibana.logstash.es/content/logstash/get-start/daemon.html" target="_blank" rel="external">需要长期后台运行的大量程序</a>,使用daemontools</p>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>参考<a href="http://blog.csdn.net/yongan1006/article/details/8134581" target="_blank" rel="external">管道命令和xargs的区别(经典解释)</a><br>管道是实现“将前面的标准输出作为后面的标准输入”<br>xargs是实现“将标准输入作为命令的参数”<br>运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">echo &quot;--help&quot;|cat</div><div class="line">echo &quot;--help&quot;|xargs cat</div></pre></td></tr></table></figure></p>
<p>得到结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">ubuntu@ubuntu-Aspire-V3-571G:~$ echo &quot;--help&quot;|cat</div><div class="line">--help</div><div class="line">ubuntu@ubuntu-Aspire-V3-571G:~$ echo &quot;--help&quot;|xargs cat</div><div class="line">用法：cat [选项]... [文件]...</div><div class="line">Concatenate FILE(s) to standard output.</div><div class="line"></div><div class="line">如果没有指定文件，或者文件为&quot;-&quot;，则从标准输入读取。</div><div class="line"></div><div class="line">  -A, --show-all           equivalent to -vET</div><div class="line">  -b, --number-nonblank    number nonempty output lines, overrides -n</div><div class="line">  -e                       equivalent to -vE</div><div class="line">  -E, --show-ends          display $ at end of each line</div><div class="line">  -n, --number             number all output lines</div><div class="line">  -s, --squeeze-blank      suppress repeated empty output lines</div><div class="line">  -t                       与-vT 等价</div><div class="line">  -T, --show-tabs          将跳格字符显示为^I</div><div class="line">  -u                       (被忽略)</div><div class="line">  -v, --show-nonprinting   使用^ 和M- 引用，除了LFD和 TAB 之外</div><div class="line">      --help		显示此帮助信息并退出</div><div class="line">      --version		显示版本信息并退出</div><div class="line"></div><div class="line">示例：</div><div class="line">  cat f - g  先输出f 的内容，然后输出标准输入的内容，最后输出g 的内容。</div><div class="line">  cat        将标准输入的内容复制到标准输出。</div><div class="line"></div><div class="line">GNU coreutils online help: &lt;http://www.gnu.org/software/coreutils/&gt;</div><div class="line">请向&lt;http://translationproject.org/team/zh_CN.html&gt; 报告cat 的翻译错误</div><div class="line">Full documentation at: &lt;http://www.gnu.org/software/coreutils/cat&gt;</div><div class="line">or available locally via: info &apos;(coreutils) cat invocation&apos;</div><div class="line">ubuntu@ubuntu-Aspire-V3-571G:~$</div></pre></td></tr></table></figure></p>
<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>批量替换字符串,如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find /etc/swift/ -name \*.conf | xargs sudo sed -i &quot;s/&lt;your-user-name&gt;/$&#123;USER&#125;/&quot;</div></pre></td></tr></table></figure></p>
<p>把/etc/swift/文件夹下 *.conf 文件中的<your-user-name>批量替换为计算机用户名<br>参考<a href="http://www.frostsky.com/2014/01/linux-sed-command/" target="_blank" rel="external">linux sed 批量替换字符串</a></your-user-name></p>
<h2 id="找出占用端口的程序"><a href="#找出占用端口的程序" class="headerlink" title="找出占用端口的程序"></a>找出占用端口的程序</h2><p>netstat -ap | grep 8080<br>lsof i:8080</p>
]]></content>
      
        <categories>
            
            <category> linux命令 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux学习-linux文件存储]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/linux%E5%AD%A6%E4%B9%A0-linux%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<h2 id="linux文件存储"><a href="#linux文件存储" class="headerlink" title="linux文件存储"></a>linux文件存储</h2><p>一直对文件存储过程不太理解,估计是操作系统没学好,今天看了这篇文章<a href="http://c.biancheng.net/cpp/html/2780.html" target="_blank" rel="external">Linux文件存储结构，包括目录项、inode、数据块</a>,感觉思路一下子清晰了. 根据linux一切皆文件的思想,目录项也作为一个文件存储,存储的内容为inode和文件名.</p>
<h2 id="linux文件查找"><a href="#linux文件查找" class="headerlink" title="linux文件查找"></a>linux文件查找</h2><p><a href="http://www.cnblogs.com/cobbliu/p/4888751.html" target="_blank" rel="external">文件系统中的目录查找</a><br><a href="http://alanwu.blog.51cto.com/3652632/1120652" target="_blank" rel="external">Linux中文件名解析处理源码分析</a></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读记录9-生成fid过程]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%959-%E7%94%9F%E6%88%90fid%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>使用命令 : curl -X POST <a href="http://localhost:9333/dir/assign" target="_blank" rel="external">http://localhost:9333/dir/assign</a></p>
<p>在topology.go 中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Topology)</span> <span class="title">PickForWrite</span><span class="params">(count <span class="keyword">uint64</span>, option *VolumeGrowOption)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">uint64</span>, *DataNode, error)</span></span> &#123;</div><div class="line">truevid, count, datanodes, err := t.GetVolumeLayout(option.Collection, option.ReplicaPlacement, option.Ttl).PickForWrite(count, option)</div><div class="line">true<span class="keyword">if</span> err != <span class="literal">nil</span> || datanodes.Length() == <span class="number">0</span> &#123;</div><div class="line">truetrue<span class="keyword">return</span> <span class="string">""</span>, <span class="number">0</span>, <span class="literal">nil</span>, errors.New(<span class="string">"No writable volumes available!"</span>)</div><div class="line">true&#125;</div><div class="line">truefileId, count := t.Sequence.NextFileId(count)   <span class="comment">// fileId = 1050682, count = 1</span></div><div class="line">true<span class="keyword">return</span> storage.NewFileId(*vid, fileId, rand.Uint32()).String(), count, datanodes.Head(), <span class="literal">nil</span>  <span class="comment">//调用file_id.go中的NewFileId函数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在file_id.go 中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> FileId <span class="keyword">struct</span> &#123;</div><div class="line">trueVolumeId VolumeId</div><div class="line">trueKey      <span class="keyword">uint64</span> <span class="comment">// fileId = 1050682</span></div><div class="line">trueHashcode <span class="keyword">uint32</span> <span class="comment">// rand.Uint32()</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFileId</span><span class="params">(VolumeId VolumeId, Key <span class="keyword">uint64</span>, Hashcode <span class="keyword">uint32</span>)</span> *<span class="title">FileId</span></span> &#123;</div><div class="line">true<span class="keyword">return</span> &amp;FileId&#123;VolumeId: VolumeId, Key: Key, Hashcode: Hashcode&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用memory_sequencer.go中的函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MemorySequencer)</span> <span class="title">NextFileId</span><span class="params">(count <span class="keyword">uint64</span>)</span> <span class="params">(<span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</span></span> &#123;  <span class="comment">// count = 1</span></div><div class="line">truem.sequenceLock.Lock()</div><div class="line">true<span class="keyword">defer</span> m.sequenceLock.Unlock()</div><div class="line">trueret := m.counter</div><div class="line">truem.counter += <span class="keyword">uint64</span>(count)</div><div class="line">true<span class="keyword">return</span> ret, count</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调试信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(dlv) p m</div><div class="line">*github.com/chrislusf/seaweedfs/weed/sequence.MemorySequencer &#123;</div><div class="line">truecounter: 1050683,</div><div class="line">truesequenceLock: sync.Mutex &#123;state: 1, sema: 0&#125;,&#125;</div></pre></td></tr></table></figure></p>
<p>在 master_server_handlers.go 中封装信息<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fid, count, dn, err := ms.Topo.PickForWrite(requestedCount, option)</div><div class="line">true<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</div><div class="line">truetruewriteJsonQuiet(w, r, http.StatusOK, operation.AssignResult&#123;Fid: fid, Url: dn.Url(), PublicUrl: dn.PublicUrl, Count: count&#125;)</div><div class="line">true&#125; <span class="keyword">else</span> &#123;</div><div class="line">truetruewriteJsonQuiet(w, r, http.StatusNotAcceptable, operation.AssignResult&#123;Error: err.Error()&#125;)</div><div class="line">true&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读8-GET&HEAD获取文件过程]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB8-GET&amp;HEAD%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>GET 文件请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://127.0.0.1:8080/27542,10088ee11dccb9</div></pre></td></tr></table></figure></p>
<p>先生成一个新的needle,然后根据fid:10088ee11dccb9 , 其中,前8位使用16进制转换为uint64 ==&gt; key, 后6位使用16进制转换为uint32 ==&gt; hash,解析结果给新生成的needle赋值,n.Id=key, n.Cookie=hash</p>
<p>如果当前的volumeServer没有找到请求的volumeId<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> !vs.store.HasVolume(volumeId) &#123;</div><div class="line">truetrue<span class="keyword">if</span> !vs.ReadRedirect &#123;</div><div class="line">truetruetrueglog.V(<span class="number">2</span>).Infoln(<span class="string">"volume is not local:"</span>, err, r.URL.Path)</div><div class="line">truetruetruew.WriteHeader(http.StatusNotFound)</div><div class="line">truetruetrue<span class="keyword">return</span></div><div class="line">truetrue&#125;</div><div class="line">truetruelookupResult, err := operation.Lookup(vs.GetMasterNode(), volumeId.String())</div><div class="line">truetrueglog.V(<span class="number">2</span>).Infoln(<span class="string">"volume"</span>, volumeId, <span class="string">"found on"</span>, lookupResult, <span class="string">"error"</span>, err)</div><div class="line">truetrue<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(lookupResult.Locations) &gt; <span class="number">0</span> &#123;</div><div class="line">truetruetrueu, _ := url.Parse(util.NormalizeUrl(lookupResult.Locations[<span class="number">0</span>].PublicUrl))</div><div class="line">truetruetrueu.Path = r.URL.Path</div><div class="line">truetruetruearg := url.Values&#123;&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> c := r.FormValue(<span class="string">"collection"</span>); c != <span class="string">""</span> &#123;</div><div class="line">truetruetruetruearg.Set(<span class="string">"collection"</span>, c)</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrueu.RawQuery = arg.Encode()</div><div class="line">truetruetruehttp.Redirect(w, r, u.String(), http.StatusMovedPermanently)</div><div class="line"></div><div class="line">truetrue&#125; <span class="keyword">else</span> &#123;</div><div class="line">truetruetrueglog.V(<span class="number">2</span>).Infoln(<span class="string">"lookup error:"</span>, err, r.URL.Path)</div><div class="line">truetruetruew.WriteHeader(http.StatusNotFound)</div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">return</span></div><div class="line">true&#125;</div></pre></td></tr></table></figure></p>
<p>在volume_read_write.go 中,调用readNeedle,通过已知的n.Id ,获取存储的needle信息,操作在needle_map_memory.go 中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nm *NeedleMap)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">uint64</span>)</span> <span class="params">(element *NeedleValue, ok <span class="keyword">bool</span>)</span></span> &#123;</div><div class="line">trueelement, ok = nm.m.Get(Key(key))</div><div class="line">true<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(dlv) p element</div><div class="line">*github.com/chrislusf/seaweedfs/weed/storage.NeedleValue &#123;Key: 1050766, Offset: 1, Size: 529810&#125;</div></pre></td></tr></table></figure>
<p>与上传信息对比<br>上传时返回信息:<br>{“fid”:”27542,10088ee11dccb9”,”fileName”:”raft.pdf”,”fileUrl”:”127.0.0.1:8080/27542,10088ee11dccb9”,”size”:529766}<br>此时信息<br>{Key: 1050766, Offset: 1, Size: 529810}<br>存储时以needle为单位,增加的大小为needle中其他数据的大小,如n.Id,n.Cookie</p>
<p>获取数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Needle)</span> <span class="title">ReadData</span><span class="params">(r *os.File, offset <span class="keyword">int64</span>, size <span class="keyword">uint32</span>, version Version)</span> <span class="params">(err error)</span></span> &#123;</div><div class="line">truebytes, block, err := ReadNeedleBlob(r, offset, size)</div><div class="line">true<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">truetrue<span class="keyword">return</span> err</div><div class="line">true&#125;</div><div class="line">truen.rawBlock = block</div><div class="line">truen.ParseNeedleHeader(bytes)</div><div class="line">true<span class="keyword">if</span> n.Size != size &#123;</div><div class="line">truetrue<span class="keyword">return</span> fmt.Errorf(<span class="string">"File Entry Not Found. Needle %d Memory %d"</span>, n.Size, size)</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">switch</span> version &#123;</div><div class="line">true<span class="keyword">case</span> Version1:</div><div class="line">truetruen.Data = bytes[NeedleHeaderSize : NeedleHeaderSize+size]</div><div class="line">true<span class="keyword">case</span> Version2:</div><div class="line">truetruen.readNeedleDataVersion2(bytes[NeedleHeaderSize : NeedleHeaderSize+<span class="keyword">int</span>(n.Size)])  <span class="comment">// 从bytes中读取存储数据,并设置needle的属性</span></div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> size == <span class="number">0</span> &#123;</div><div class="line">truetrue<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">true&#125;</div><div class="line">truechecksum := util.BytesToUint32(bytes[NeedleHeaderSize+size : NeedleHeaderSize+size+NeedleChecksumSize])</div><div class="line">truenewChecksum := NewCRC(n.Data)</div><div class="line">true<span class="keyword">if</span> checksum != newChecksum.Value() &#123;</div><div class="line">truetrue<span class="keyword">return</span> errors.New(<span class="string">"CRC error! Data On Disk Corrupted"</span>)</div><div class="line">true&#125;</div><div class="line">truen.Checksum = newChecksum</div><div class="line">true<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Needle)</span> <span class="title">readNeedleDataVersion2</span><span class="params">(bytes []<span class="keyword">byte</span>)</span></span> &#123;</div><div class="line">trueindex, lenBytes := <span class="number">0</span>, <span class="built_in">len</span>(bytes)</div><div class="line">true<span class="keyword">if</span> index &lt; lenBytes &#123;</div><div class="line">truetruen.DataSize = util.BytesToUint32(bytes[index : index+<span class="number">4</span>])</div><div class="line">truetrueindex = index + <span class="number">4</span></div><div class="line">truetrue<span class="keyword">if</span> <span class="keyword">int</span>(n.DataSize)+index &gt; lenBytes &#123;</div><div class="line">truetruetrue<span class="comment">// this if clause is due to bug #87 and #93, fixed in v0.69</span></div><div class="line">truetruetrue<span class="comment">// remove this clause later</span></div><div class="line">truetruetrue<span class="keyword">return</span></div><div class="line">truetrue&#125;</div><div class="line">truetruen.Data = bytes[index : index+<span class="keyword">int</span>(n.DataSize)]</div><div class="line">truetrueindex = index + <span class="keyword">int</span>(n.DataSize)</div><div class="line">truetruen.Flags = bytes[index]</div><div class="line">truetrueindex = index + <span class="number">1</span></div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> index &lt; lenBytes &amp;&amp; n.HasName() &#123;</div><div class="line">truetruen.NameSize = <span class="keyword">uint8</span>(bytes[index])</div><div class="line">truetrueindex = index + <span class="number">1</span></div><div class="line">truetruen.Name = bytes[index : index+<span class="keyword">int</span>(n.NameSize)]</div><div class="line">truetrueindex = index + <span class="keyword">int</span>(n.NameSize)</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> index &lt; lenBytes &amp;&amp; n.HasMime() &#123;</div><div class="line">truetruen.MimeSize = <span class="keyword">uint8</span>(bytes[index])</div><div class="line">truetrueindex = index + <span class="number">1</span></div><div class="line">truetruen.Mime = bytes[index : index+<span class="keyword">int</span>(n.MimeSize)]</div><div class="line">truetrueindex = index + <span class="keyword">int</span>(n.MimeSize)</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> index &lt; lenBytes &amp;&amp; n.HasLastModifiedDate() &#123;</div><div class="line">truetruen.LastModified = util.BytesToUint64(bytes[index : index+LastModifiedBytesLength])</div><div class="line">truetrueindex = index + LastModifiedBytesLength</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> index &lt; lenBytes &amp;&amp; n.HasTtl() &#123;</div><div class="line">truetruen.Ttl = LoadTTLFromBytes(bytes[index : index+TtlBytesLength])</div><div class="line">truetrueindex = index + TtlBytesLength</div><div class="line">true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据请求URL中带有的fid, 解析,得到n.Id, n.Cookie,其中,n.Id 作为needle的唯一标识,在NeedleMapper中找到存储的needle信息,n.Cookie 作为数据验证信息,若找到的needle中的cookie于URL中的cookie不一致,返回错误信息.</p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读7-文件存储过程]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB7-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>文件在volume_server_handlers_write.go 中的topology.ReplicatedWrite中以needle的形式存储,在store.go 的Write方法中调用writeNeedle写入文件.<br>写入时使用append的方法,在文件中追加<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// needle_read_write.go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Needle)</span> <span class="title">Append</span><span class="params">(w io.Writer, version Version)</span> <span class="params">(size <span class="keyword">uint32</span>, err error)</span></span> &#123;</div><div class="line">true<span class="keyword">if</span> s, ok := w.(io.Seeker); ok &#123;</div><div class="line">truetrue<span class="keyword">if</span> end, e := s.Seek(<span class="number">0</span>, <span class="number">1</span>); e == <span class="literal">nil</span> &#123;</div><div class="line">truetruetrue<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(s io.Seeker, off <span class="keyword">int64</span>)</span></span> &#123;</div><div class="line">truetruetruetrue<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">if</span> _, e = s.Seek(off, <span class="number">0</span>); e != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetruetrueglog.V(<span class="number">0</span>).Infof(<span class="string">"Failed to seek %s back to %d with error: %v"</span>, w, off, e)</div><div class="line">truetruetruetruetrue&#125;</div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetrue&#125;(s, end)</div><div class="line">truetrue&#125; <span class="keyword">else</span> &#123;</div><div class="line">truetruetrueerr = fmt.Errorf(<span class="string">"Cannot Read Current Volume Position: %v"</span>, e)</div><div class="line">truetruetrue<span class="keyword">return</span></div><div class="line">truetrue&#125;</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">switch</span> version &#123;</div><div class="line">true<span class="keyword">case</span> Version1:</div><div class="line">truetrueheader := <span class="built_in">make</span>([]<span class="keyword">byte</span>, NeedleHeaderSize)</div><div class="line">truetrueutil.Uint32toBytes(header[<span class="number">0</span>:<span class="number">4</span>], n.Cookie)</div><div class="line">truetrueutil.Uint64toBytes(header[<span class="number">4</span>:<span class="number">12</span>], n.Id)</div><div class="line">truetruen.Size = <span class="keyword">uint32</span>(<span class="built_in">len</span>(n.Data))</div><div class="line">truetruesize = n.Size</div><div class="line">truetrueutil.Uint32toBytes(header[<span class="number">12</span>:<span class="number">16</span>], n.Size)</div><div class="line">truetrue<span class="keyword">if</span> _, err = w.Write(header); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetrue<span class="keyword">return</span></div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">if</span> _, err = w.Write(n.Data); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetrue<span class="keyword">return</span></div><div class="line">truetrue&#125;</div><div class="line">truetruepadding := NeedlePaddingSize - ((NeedleHeaderSize + n.Size + NeedleChecksumSize) % NeedlePaddingSize)</div><div class="line">truetrueutil.Uint32toBytes(header[<span class="number">0</span>:NeedleChecksumSize], n.Checksum.Value())</div><div class="line">truetrue_, err = w.Write(header[<span class="number">0</span> : NeedleChecksumSize+padding])</div><div class="line">truetrue<span class="keyword">return</span></div><div class="line">true<span class="keyword">case</span> Version2:</div><div class="line">truetrueheader := <span class="built_in">make</span>([]<span class="keyword">byte</span>, NeedleHeaderSize)</div><div class="line">truetrueutil.Uint32toBytes(header[<span class="number">0</span>:<span class="number">4</span>], n.Cookie)</div><div class="line">truetrueutil.Uint64toBytes(header[<span class="number">4</span>:<span class="number">12</span>], n.Id)</div><div class="line">truetruen.DataSize, n.NameSize, n.MimeSize = <span class="keyword">uint32</span>(<span class="built_in">len</span>(n.Data)), <span class="keyword">uint8</span>(<span class="built_in">len</span>(n.Name)), <span class="keyword">uint8</span>(<span class="built_in">len</span>(n.Mime))</div><div class="line">truetrue<span class="keyword">if</span> n.DataSize &gt; <span class="number">0</span> &#123;</div><div class="line">truetruetruen.Size = <span class="number">4</span> + n.DataSize + <span class="number">1</span></div><div class="line">truetruetrue<span class="keyword">if</span> n.HasName() &#123;</div><div class="line">truetruetruetruen.Size = n.Size + <span class="number">1</span> + <span class="keyword">uint32</span>(n.NameSize)</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasMime() &#123;</div><div class="line">truetruetruetruen.Size = n.Size + <span class="number">1</span> + <span class="keyword">uint32</span>(n.MimeSize)</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasLastModifiedDate() &#123;</div><div class="line">truetruetruetruen.Size = n.Size + LastModifiedBytesLength</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasTtl() &#123;</div><div class="line">truetruetruetruen.Size = n.Size + TtlBytesLength</div><div class="line">truetruetrue&#125;</div><div class="line">truetrue&#125; <span class="keyword">else</span> &#123;</div><div class="line">truetruetruen.Size = <span class="number">0</span></div><div class="line">truetrue&#125;</div><div class="line">truetruesize = n.DataSize</div><div class="line">truetrueutil.Uint32toBytes(header[<span class="number">12</span>:<span class="number">16</span>], n.Size)</div><div class="line">truetrue<span class="keyword">if</span> _, err = w.Write(header); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetrue<span class="keyword">return</span></div><div class="line">truetrue&#125;</div><div class="line">truetrue<span class="keyword">if</span> n.DataSize &gt; <span class="number">0</span> &#123;</div><div class="line">truetruetrueutil.Uint32toBytes(header[<span class="number">0</span>:<span class="number">4</span>], n.DataSize)</div><div class="line">truetruetrue<span class="keyword">if</span> _, err = w.Write(header[<span class="number">0</span>:<span class="number">4</span>]); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> _, err = w.Write(n.Data); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrueutil.Uint8toBytes(header[<span class="number">0</span>:<span class="number">1</span>], n.Flags)</div><div class="line">truetruetrue<span class="keyword">if</span> _, err = w.Write(header[<span class="number">0</span>:<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasName() &#123;</div><div class="line">truetruetruetrueutil.Uint8toBytes(header[<span class="number">0</span>:<span class="number">1</span>], n.NameSize)</div><div class="line">truetruetruetrue<span class="keyword">if</span> _, err = w.Write(header[<span class="number">0</span>:<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetruetrue<span class="keyword">if</span> _, err = w.Write(n.Name); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasMime() &#123;</div><div class="line">truetruetruetrueutil.Uint8toBytes(header[<span class="number">0</span>:<span class="number">1</span>], n.MimeSize)</div><div class="line">truetruetruetrue<span class="keyword">if</span> _, err = w.Write(header[<span class="number">0</span>:<span class="number">1</span>]); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetruetrue<span class="keyword">if</span> _, err = w.Write(n.Mime); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasLastModifiedDate() &#123;</div><div class="line">truetruetruetrueutil.Uint64toBytes(header[<span class="number">0</span>:<span class="number">8</span>], n.LastModified)</div><div class="line">truetruetruetrue<span class="keyword">if</span> _, err = w.Write(header[<span class="number">8</span>-LastModifiedBytesLength : <span class="number">8</span>]); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetrue&#125;</div><div class="line">truetruetrue<span class="keyword">if</span> n.HasTtl() &amp;&amp; n.Ttl != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruen.Ttl.ToBytes(header[<span class="number">0</span>:TtlBytesLength])</div><div class="line">truetruetruetrue<span class="keyword">if</span> _, err = w.Write(header[<span class="number">0</span>:TtlBytesLength]); err != <span class="literal">nil</span> &#123;</div><div class="line">truetruetruetruetrue<span class="keyword">return</span></div><div class="line">truetruetruetrue&#125;</div><div class="line">truetruetrue&#125;</div><div class="line">truetrue&#125;</div><div class="line">truetruepadding := NeedlePaddingSize - ((NeedleHeaderSize + n.Size + NeedleChecksumSize) % NeedlePaddingSize)</div><div class="line">truetrueutil.Uint32toBytes(header[<span class="number">0</span>:NeedleChecksumSize], n.Checksum.Value())</div><div class="line">truetrue_, err = w.Write(header[<span class="number">0</span> : NeedleChecksumSize+padding])</div><div class="line">truetrue<span class="keyword">return</span> n.DataSize, err</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"Unsupported Version! (%d)"</span>, version)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读6-文件存储格式]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB6-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>使用put 上传文件到seaweedfs , 具体显示结果<br><img src="http://oh56h8a9l.bkt.clouddn.com/seaweedfs源码阅读6-20161212.png" alt="seaweedfs源码阅读6-20161212"></p>
<p>上传的所有文件都以单个文件进行存储,后缀为 .dat 和 .idx<br><img src="http://oh56h8a9l.bkt.clouddn.com/seaweefs源码阅读6-2-20161212.png" alt="seaweefs源码阅读6-2-20161212"></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读5-文件PUT过程]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-%E6%96%87%E4%BB%B6PUT%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; curl -X POST http://localhost:9333/dir/assign</div><div class="line">&#123;<span class="string">"count"</span>:1,<span class="string">"fid"</span>:<span class="string">"3,01637037d6"</span>,<span class="string">"url"</span>:<span class="string">"127.0.0.1:8080"</span>,<span class="string">"publicUrl"</span>:<span class="string">"localhost:8080"</span>&#125;</div><div class="line">&gt; curl -X PUT -F file=@/home/chris/myphoto.jpg http://127.0.0.1:8080/3,01637037d6</div><div class="line">&#123;<span class="string">"size"</span>: 43234&#125;</div></pre></td></tr></table></figure></p>
<p>上传文件,程序调用volume_server_handlers_write.go 中的PostHandler进行处理,根据URL,提取vid,生成新的volumeId<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vid, _, _, _, _ := parseURLPath(r.URL.Path) <span class="comment">//vid 为3</span></div><div class="line">volumeId, ve := storage.NewVolumeId(vid) <span class="comment">// volumeId : 7</span></div></pre></td></tr></table></figure></p>
<p>根据请求参数,生成needle<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">needle, ne := storage.NewNeedle(r, vs.FixJpgOrientation)</div></pre></td></tr></table></figure></p>
<p>使用multipartReader读取请求中的数据,有关multipart的介绍: <a href="http://wanlitian.github.io/2014/11/16/multipart_with_golang/" target="_blank" rel="external">golang的multipart包</a><br>使用needle.go 中的ParseUpload方法解析请求,得到上传的文件名和数据;<br>如果上传的数据类型是JPG或jpeg,调用 images.FixJpgOrientation(n.Data)对数据进行处理<br>生成needle过程<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNeedle</span><span class="params">(r *http.Request, fixJpgOrientation <span class="keyword">bool</span>)</span> <span class="params">(n *Needle, e error)</span></span> &#123;</div><div class="line">truefname, mimeType, isGzipped, isChunkedFile := <span class="string">""</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="literal">false</span></div><div class="line">truen = <span class="built_in">new</span>(Needle)</div><div class="line">truefname, n.Data, mimeType, isGzipped, n.LastModified, n.Ttl, isChunkedFile, e = ParseUpload(r)</div><div class="line">true<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</div><div class="line">truetrue<span class="keyword">return</span></div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> <span class="built_in">len</span>(fname) &lt; <span class="number">256</span> &#123;</div><div class="line">truetruen.Name = []<span class="keyword">byte</span>(fname)</div><div class="line">truetruen.SetHasName()</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> <span class="built_in">len</span>(mimeType) &lt; <span class="number">256</span> &#123;</div><div class="line">truetruen.Mime = []<span class="keyword">byte</span>(mimeType)</div><div class="line">truetruen.SetHasMime()</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> isGzipped &#123;</div><div class="line">truetruen.SetGzipped()</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">if</span> n.LastModified == <span class="number">0</span> &#123;</div><div class="line">truetruen.LastModified = <span class="keyword">uint64</span>(time.Now().Unix())</div><div class="line">true&#125;</div><div class="line">truen.SetHasLastModifiedDate()</div><div class="line">true<span class="keyword">if</span> n.Ttl != EMPTY_TTL &#123;</div><div class="line">truetruen.SetHasTtl()</div><div class="line">true&#125;</div><div class="line"></div><div class="line">true<span class="keyword">if</span> isChunkedFile &#123;</div><div class="line">truetruen.SetIsChunkManifest()</div><div class="line">true&#125;</div><div class="line"></div><div class="line">true<span class="keyword">if</span> fixJpgOrientation &#123;</div><div class="line">truetrueloweredName := strings.ToLower(fname)</div><div class="line">truetrue<span class="keyword">if</span> mimeType == <span class="string">"image/jpeg"</span> || strings.HasSuffix(loweredName, <span class="string">".jpg"</span>) || strings.HasSuffix(loweredName, <span class="string">".jpeg"</span>) &#123;</div><div class="line">truetruetruen.Data = images.FixJpgOrientation(n.Data)</div><div class="line">truetrue&#125;</div><div class="line">true&#125;</div><div class="line"></div><div class="line">truen.Checksum = NewCRC(n.Data)</div><div class="line"></div><div class="line">truecommaSep := strings.LastIndex(r.URL.Path, <span class="string">","</span>)</div><div class="line">truedotSep := strings.LastIndex(r.URL.Path, <span class="string">"."</span>)</div><div class="line">truefid := r.URL.Path[commaSep+<span class="number">1</span>:]</div><div class="line">true<span class="keyword">if</span> dotSep &gt; <span class="number">0</span> &#123;</div><div class="line">truetruefid = r.URL.Path[commaSep+<span class="number">1</span> : dotSep]</div><div class="line">true&#125;</div><div class="line"></div><div class="line">truee = n.ParsePath(fid)</div><div class="line"></div><div class="line">true<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>把数据及needle相关属性填充完成后,同步到其他volumeServer中,已needle作为传输载体<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size, errorStatus := topology.ReplicatedWrite(vs.GetMasterNode(),vs.store, volumeId, needle, r)</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读4-volume启动过程]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4-volume%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>根据文章<a href="http://www.cppblog.com/sunicdavy/archive/2016/09/03/214254.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">使用delve调试Golang程序技巧</a><br>使用go install -gcflags “-N -l” weed.go 对程序进行重新编译,方便调试</p>
<p>通过weed.go 调用volume.go ,参数处理完成后,生成一个ServeMux实例,有关<a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/03.4.md" target="_blank" rel="external">go http ServeMux介绍</a>,<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">volumeMux := http.NewServeMux()</div><div class="line">publicVolumeMux := volumeMux</div><div class="line"><span class="keyword">if</span> isSeperatedPublicPort &#123;</div><div class="line">truepublicVolumeMux = http.NewServeMux()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据参数VolumeServerOptions 中的 indexType,选择volume Needle Map 的存储位置,默认使用内存<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">volumeNeedleMapKind := storage.NeedleMapInMemory</div><div class="line"><span class="keyword">switch</span> *v.indexType &#123;</div><div class="line"><span class="keyword">case</span> <span class="string">"leveldb"</span>:</div><div class="line">  volumeNeedleMapKind = storage.NeedleMapLevelDb</div><div class="line"><span class="keyword">case</span> <span class="string">"boltdb"</span>:</div><div class="line">  volumeNeedleMapKind = storage.NeedleMapBoltDb</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调试信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(dlv) p *v.indexType</div><div class="line"><span class="string">"memory"</span></div></pre></td></tr></table></figure></p>
<p>根据参数生成volumeServer,使用volume_server.go 中的NewVolumeServer 生成volumeServer<br>在volume_server.go 中,设置masterNode ,store, guard<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vs.SetMasterNode(masterNode)</div><div class="line">vs.store = storage.NewStore(port, ip, publicUrl, folders, maxCounts, vs.needleMapKind)</div><div class="line"></div><div class="line">vs.guard = security.NewGuard(whiteList, <span class="string">""</span>)</div></pre></td></tr></table></figure></p>
<p>生成store时会加载已有的volume<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// store.go</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(port <span class="keyword">int</span>, ip, publicUrl <span class="keyword">string</span>, dirnames []<span class="keyword">string</span>, maxVolumeCounts []<span class="keyword">int</span>, needleMapKind NeedleMapType)</span> <span class="params">(s *Store)</span></span> &#123;</div><div class="line">trues = &amp;Store&#123;Port: port, Ip: ip, PublicUrl: publicUrl&#125;</div><div class="line">trues.Locations = <span class="built_in">make</span>([]*DiskLocation, <span class="number">0</span>)</div><div class="line">true<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dirnames); i++ &#123;</div><div class="line">truetruelocation := NewDiskLocation(dirnames[i], maxVolumeCounts[i])</div><div class="line">truetruelocation.loadExistingVolumes(needleMapKind)</div><div class="line">truetrues.Locations = <span class="built_in">append</span>(s.Locations, location)</div><div class="line">true&#125;</div><div class="line">true<span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang调试技巧]]></title>
      <url>https://makeitpossible16.github.io/go/golang%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<p>在阅读seaweedfs过程中,发现对于复杂程序,跟踪调试相当困难,不过,在看了<a href="http://www.cppblog.com/sunicdavy/archive/2016/09/03/214254.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">使用delve调试Golang程序技巧</a>这篇文章后,调试问题得到很好的改善.</p>
<p>首先,liteIDE简直让人眼前一亮,使用它并结合delve实现图形化界面调试,使用命令行多少有点不太方便,特别是当你想在源码中加入注释的时候.</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol>
<li><p>安装delve,liteIDE</p>
</li>
<li><p>加入参数关闭编译器优化,如 go install -gcflags “-N -l” 程序名称</p>
</li>
<li><p>按照文章<a href="http://www.cppblog.com/sunicdavy/archive/2016/09/03/214254.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">使用delve调试Golang程序技巧</a>, 调试外部程序</p>
</li>
<li><p>调试启动后,可在Console设置断点, 命令为 : b packageName.functionName 或 b lineNum</p>
</li>
<li><p>使用命令c ,运行到断点停止,进行操作,具体命令可参照delve</p>
</li>
</ol>
<p>还不清楚liteIDE能不能使用delve 进行图形化attach,如果可以就非常完美</p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang 反射机制]]></title>
      <url>https://makeitpossible16.github.io/go/golang%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>在阅读seaweedfs过程中,当程序在运行过程中,想要进行跟踪调试不好实现,目前也没找到很好的解决方案,只能跟踪程序的启动过程.不过回归最原始的方法,使用printf倒是可以查看变量的值,因此打算编写程序,把struct中的变量转化为json,发送给搭建的服务器,实现查看struct变量的方法.其中就了解到go的反射机制.</p>
<p><a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="external">laws-of-reflection</a><br><a href="http://blog.csdn.net/liuxinmingcode/article/details/50480097" target="_blank" rel="external">Golang之反射reflect包</a></p>
<p>使用反射可以得到struct中的变量及变量的值,前提是该变量是export的,即首字母大写,类似java中的public.    </p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang学习]]></title>
      <url>https://makeitpossible16.github.io/go/golang%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>在看seaweedfs过程中遇到的go 语法,不会的记录一下.</p>
<h2 id="interface-是一组method的组合-通过interface来定义对象的一组行为"><a href="#interface-是一组method的组合-通过interface来定义对象的一组行为" class="headerlink" title="interface: 是一组method的组合,通过interface来定义对象的一组行为."></a>interface: 是一组method的组合,通过interface来定义对象的一组行为.</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Sequencer <span class="keyword">interface</span> &#123;</div><div class="line">trueNextFileId(count <span class="keyword">uint64</span>) (<span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</div><div class="line">trueSetMax(<span class="keyword">uint64</span>)</div><div class="line">truePeek() <span class="keyword">uint64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="go-map"><a href="#go-map" class="headerlink" title="go map"></a>go map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">t.children = <span class="built_in">make</span>(<span class="keyword">map</span>[NodeId]Node)  <span class="comment">// NodeId --&gt; Node</span></div></pre></td></tr></table></figure>
<h2 id="go-sync-RWMutex和sync-Mutex"><a href="#go-sync-RWMutex和sync-Mutex" class="headerlink" title="go sync.RWMutex和sync.Mutex"></a>go <a href="http://studygolang.com/articles/3373" target="_blank" rel="external">sync.RWMutex和sync.Mutex</a></h2><p>golang中sync包实现了两种锁Mutex （互斥锁）和RWMutex（读写锁），其中RWMutex是基于Mutex实现的，只读锁的实现使用类似引用计数器的功能．<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Mutex</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span> <span class="title">Lock</span><span class="params">()</span></span></div><div class="line">    <span class="title">func</span> <span class="params">(m *Mutex)</span> <span class="title">Unlock</span><span class="params">()</span></div></pre></td></tr></table></figure></p>
<p>Mutex为互斥锁，Lock()加锁，Unlock()解锁，使用Lock()加锁后，便不能再次对其进行加锁，直到利用Unlock()解锁对其解锁后，才能再次加锁．适用于读写不确定场景，即读写次数没有明显的区别，并且只允许只有一个读或者写的场景，所以该锁也叫做全局锁．</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RWMutex</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span></span></div><div class="line">    <span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span></div><div class="line">    <span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLocker</span><span class="params">()</span> <span class="title">Locker</span></div><div class="line">    <span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></div><div class="line">    <span class="title">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></div></pre></td></tr></table></figure>
<p>func (rw <em>RWMutex) Lock()　　写锁，如果在添加写锁之前已经有其他的读锁和写锁，则lock就会阻塞直到该锁可用，为确保该锁最终可用，已阻塞的 Lock 调用会从获得的锁中排除新的读取器，即写锁权限高于读锁，有写锁时优先进行写锁定<br> func (rw </em>RWMutex) Unlock()　写锁解锁，如果没有进行写锁定，则就会引起一个运行时错误．<br> func (rw *RWMutex) RLock() 读锁，当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载读锁，读锁可以加载多个，所以适用于＂读多写少＂的场景</p>
<p>func (rw *RWMutex)RUnlock()　读锁解锁，RUnlock 撤销单次 RLock 调用，它对于其它同时存在的读取器则没有效果。若 rw 并没有为读取而锁定，调用 RUnlock 就会引发一个运行时错误(注：这种说法在go1.3版本中是不对的，例如下面这个例子)。</p>
<h2 id="go-Routine和Channel"><a href="#go-Routine和Channel" class="headerlink" title="go Routine和Channel"></a>go Routine和Channel</h2><p><a href="http://blog.csdn.net/colouful987/article/details/45190319" target="_blank" rel="external">go学习笔记_Routine和Channel上</a></p>
<p>goroutine 类似开辟进程、线程做法<br>语法：</p>
<pre><code>1. 定义一个函数functionName，要异步调用时使用语句go functionName即可。

2. 使用匿名函数，用法为go func(参数列表){函数执行体}()，说明最后一个()作用就是让该函数执行。
</code></pre><p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/////////第一种示例代码：///////////</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(name <span class="keyword">string</span>)</span></span>&#123;</div><div class="line">    fmt.Println(<span class="string">"hello"</span>+name)</div><div class="line">&#125;</div><div class="line"><span class="comment">//主程序入口</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">go</span> sayHello(<span class="string">"PMST"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">/////////第二种示例代码：//////////</span></div><div class="line"><span class="comment">//主程序入口</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</div><div class="line">        fmt.Println(<span class="string">"hello world"</span>)</div><div class="line">    &#125;()     <span class="comment">//别忘记这里的()</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦将go放在函数之前，意味分配一个子routine让这个函数自个玩去(有点自身自灭的感觉),而主routine则继续该干嘛干嘛。</p>
<p>channel<br>goroutine 之间进行数据通信方式：</p>
<ol>
<li>共用内存内存空间。</li>
<li>Go语言推荐的通信机制channel。</li>
</ol>
<p>通过make来创建channel,例如<br>无缓存ci := make(chan int),<br>指定缓存cib := make(chan int,2)。给这个通道分类了2个缓存空间</p>
<p>通道的接收和发送都是阻塞的，除非与之对应的一端已经准备好<br>阻塞状态：</p>
<ol>
<li>数据写入channel（或缓存已满）却没读出</li>
<li>channel中没有数据，读channel会阻塞。</li>
</ol>
<h2 id="go反引号"><a href="#go反引号" class="headerlink" title="go反引号"></a>go反引号</h2><p>参考文章:<a href="http://studygolang.com/articles/2553" target="_blank" rel="external">GoLang获取struct的tag</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> AppendEntriesRequest <span class="keyword">struct</span> &#123;</div><div class="line">trueTerm             *<span class="keyword">uint64</span>     <span class="string">`protobuf:"varint,1,req" json:"Term,omitempty"`</span></div><div class="line">truePrevLogIndex     *<span class="keyword">uint64</span>     <span class="string">`protobuf:"varint,2,req" json:"PrevLogIndex,omitempty"`</span></div><div class="line">truePrevLogTerm      *<span class="keyword">uint64</span>     <span class="string">`protobuf:"varint,3,req" json:"PrevLogTerm,omitempty"`</span></div><div class="line">trueCommitIndex      *<span class="keyword">uint64</span>     <span class="string">`protobuf:"varint,4,req" json:"CommitIndex,omitempty"`</span></div><div class="line">trueLeaderName       *<span class="keyword">string</span>     <span class="string">`protobuf:"bytes,5,req" json:"LeaderName,omitempty"`</span></div><div class="line">trueEntries          []*LogEntry <span class="string">`protobuf:"bytes,6,rep" json:"Entries,omitempty"`</span></div><div class="line">trueXXX_unrecognized []<span class="keyword">byte</span>      <span class="string">`json:"-"`</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中,反引号表示字符串,struct后面的字符串用于reflect,具体用法<br>s := AppendEntriesRequest{}<br>st := reflect.TypeOf(s)<br>field := st.Field(0)<br>field.Tag.Get(“protobuf”) // varint,1,req<br>field.Tag.Get(“json”) // Term,omitempty</p>
<h2 id="go-get-安装程序错误"><a href="#go-get-安装程序错误" class="headerlink" title="go get 安装程序错误"></a>go get 安装程序错误</h2><p>错误提示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">unrecognized import path <span class="string">"code.google.com/p/goprotobuf/proto"</span></div><div class="line"></div><div class="line">parse https://code.google.com/p/goprotobuf?go-get=1: no go-import meta tags</div></pre></td></tr></table></figure></p>
<p>错误原因:依赖包已从code.google.com移除, 已重定向到github.com/golang/protobuf/proto,修改程序中的代码即可</p>
<h2 id="strconv-ParseInt-s-string-base-int-bitSize-int-i-int64-err-error-或strconv-ParseUint"><a href="#strconv-ParseInt-s-string-base-int-bitSize-int-i-int64-err-error-或strconv-ParseUint" class="headerlink" title="strconv.ParseInt(s string, base int, bitSize int) (i int64, err error)  或strconv.ParseUint"></a>strconv.ParseInt(s string, base int, bitSize int) (i int64, err error)  或strconv.ParseUint</h2><p>把字符串转换为整数,<br>参数1 数字的字符串形式</p>
<p>参数2 数字字符串的进制 比如二进制 八进制 十进制 十六进制</p>
<p>参数3 返回结果的bit大小 也就是int8 int16 int32 int64</p>
]]></content>
      
        <categories>
            
            <category> go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读记录3-raft协议理解]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%953-raft%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>raft用于seaweedfs的多个master server间进行leader选举,选出leader对其他master server进行管理.</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://blog.csdn.net/cszhouwei/article/details/38374603" target="_blank" rel="external">Raft一致性算法</a><br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">raft动画演示</a><br><a href="https://raft.github.io/" target="_blank" rel="external">raft介绍</a><br><a href="https://ayende.com/blog/165858/reviewing-go-raft-part-i" target="_blank" rel="external">go-raft源码解析</a><br><a href="https://godoc.org/github.com/coreos/etcd/raft" target="_blank" rel="external">go-raft文档</a><br><a href="https://github.com/goraft/raftd" target="_blank" rel="external">goraft的简单实现</a><br><a href="http://www.tuicool.com/articles/MV77ba" target="_blank" rel="external">分布式一致性，Raft以及其它</a></p>
<h2 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h2><p>本文按照参考文章中的go-raft源码解析中的文章阅读,记录阅读过程.<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The request sent to a server to append entries to the log.</span></div><div class="line"><span class="keyword">type</span> AppendEntriesRequest <span class="keyword">struct</span> &#123;</div><div class="line">trueTerm         <span class="keyword">uint64</span></div><div class="line">truePrevLogIndex <span class="keyword">uint64</span></div><div class="line">truePrevLogTerm  <span class="keyword">uint64</span></div><div class="line">trueCommitIndex  <span class="keyword">uint64</span></div><div class="line">trueLeaderName   <span class="keyword">string</span></div><div class="line">trueEntries      []*protobuf.LogEntry  <span class="comment">// 定义在protobuf中的LogEntry</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// The response returned from a server appending entries to the log.</span></div><div class="line"><span class="keyword">type</span> AppendEntriesResponse <span class="keyword">struct</span> &#123;</div><div class="line">truepb     *protobuf.AppendEntriesResponse</div><div class="line">truepeer   <span class="keyword">string</span></div><div class="line">true<span class="built_in">append</span> <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
            <tag> raft </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读记录2]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%952/</url>
      <content type="html"><![CDATA[<h2 id="master启动过程"><a href="#master启动过程" class="headerlink" title="master启动过程"></a>master启动过程</h2><p>使用pycharm , 入口为weed.go, 根据参数调用command文件夹下的文件.<br>opology 核心模块，主要包括 【DataCenter, Rack, DataNode】 三层拓扑结构,<br>参考文章： <a href="http://blog.csdn.net/baogang409/article/details/42105367" target="_blank" rel="external">weed-fs 源码解读</a></p>
<p><img src="http://oh56h8a9l.bkt.clouddn.com/master启动-20161128.svg" alt="master启动-20161128"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Sequencer <span class="keyword">interface</span> &#123;</div><div class="line">trueNextFileId(count <span class="keyword">uint64</span>) (<span class="keyword">uint64</span>, <span class="keyword">uint64</span>)</div><div class="line">trueSetMax(<span class="keyword">uint64</span>)</div><div class="line">truePeek() <span class="keyword">uint64</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>topology中包含Sequencer , sequence 负责FileID的全局有序生成</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Topology <span class="keyword">struct</span> &#123;</div><div class="line">trueNodeImpl   <span class="comment">//指向NodeImpl对象，即Topology和node相互指向</span></div><div class="line"></div><div class="line">truecollectionMap *util.ConcurrentReadMap</div><div class="line"></div><div class="line">truepulse <span class="keyword">int64</span></div><div class="line"></div><div class="line">truevolumeSizeLimit <span class="keyword">uint64</span></div><div class="line"></div><div class="line">trueSequence sequence.Sequencer</div><div class="line"></div><div class="line">truechanDeadDataNodes      <span class="keyword">chan</span> *DataNode</div><div class="line">truechanRecoveredDataNodes <span class="keyword">chan</span> *DataNode</div><div class="line">truechanFullVolumes        <span class="keyword">chan</span> storage.VolumeInfo</div><div class="line"></div><div class="line">trueconfiguration *Configuration</div><div class="line"></div><div class="line">trueRaftServer raft.Server</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>NodeImpl结构<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NodeImpl <span class="keyword">struct</span> &#123;</div><div class="line">trueid                NodeId</div><div class="line">truevolumeCount       <span class="keyword">int</span></div><div class="line">trueactiveVolumeCount <span class="keyword">int</span></div><div class="line">truemaxVolumeCount    <span class="keyword">int</span></div><div class="line">trueparent            Node</div><div class="line">truesync.RWMutex      <span class="comment">// lock children</span></div><div class="line">truechildren          <span class="keyword">map</span>[NodeId]Node</div><div class="line">truemaxVolumeId       storage.VolumeId</div><div class="line"></div><div class="line">true<span class="comment">//for rack, data center, topology</span></div><div class="line">truenodeType <span class="keyword">string</span></div><div class="line">truevalue    <span class="keyword">interface</span>&#123;&#125;  <span class="comment">//指向Topology对象，即Topology和node相互指向</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DataNode数据结构<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> DataNode <span class="keyword">struct</span> &#123;</div><div class="line">trueNodeImpl</div><div class="line">truevolumes   <span class="keyword">map</span>[storage.VolumeId]storage.VolumeInfo</div><div class="line">trueIp        <span class="keyword">string</span></div><div class="line">truePort      <span class="keyword">int</span></div><div class="line">truePublicUrl <span class="keyword">string</span></div><div class="line">trueLastSeen  <span class="keyword">int64</span> <span class="comment">// unix time in seconds</span></div><div class="line">trueDead      <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> VolumeInfo <span class="keyword">struct</span> &#123;</div><div class="line">trueId               VolumeId</div><div class="line">trueSize             <span class="keyword">uint64</span></div><div class="line">trueReplicaPlacement *ReplicaPlacement</div><div class="line">trueTtl              *TTL</div><div class="line">trueCollection       <span class="keyword">string</span></div><div class="line">trueVersion          Version</div><div class="line">trueFileCount        <span class="keyword">int</span></div><div class="line">trueDeleteCount      <span class="keyword">int</span></div><div class="line">trueDeletedByteCount <span class="keyword">uint64</span></div><div class="line">trueReadOnly         <span class="keyword">bool</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过RaftServer的raft协议，完成多个weedmaster间投票选leader的事情,<br>当启动多个ServerMaster时，它们之间会进行通信，通过raft协议选举出一个Leader，对所有的master进行管理。<br>weed-fs中，通过使用raftServer完成上述选举过程；而raftServer则是用到了第三方资源，即goRaft（参照<a href="http://ayende.com/blog/165858/reviewing-go-raft-part-i）。" target="_blank" rel="external">http://ayende.com/blog/165858/reviewing-go-raft-part-i）。</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> RaftServer <span class="keyword">struct</span> &#123;</div><div class="line">truepeers      []<span class="keyword">string</span> <span class="comment">// initial peers to join with</span></div><div class="line">trueraftServer raft.Server  <span class="comment">//使用goraft //type Server interface 包含实现raft的方法</span></div><div class="line">truedataDir    <span class="keyword">string</span></div><div class="line">truehttpAddr   <span class="keyword">string</span></div><div class="line">truerouter     *mux.Router</div><div class="line">truetopo       *topology.Topology</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[seaweedfs源码阅读记录1]]></title>
      <url>https://makeitpossible16.github.io/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/seaweedfs%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>接下来的日子都会抽出部分时间学习文件存储,目标是修改openstack-swift的源码,通过源码学习文件存储知识.目前学习对象:<a href="https://github.com/chrislusf/seaweedfs" target="_blank" rel="external">seaweedfs</a>.</p>
<h2 id="目标-学习seaweedfs-的文件合并存储"><a href="#目标-学习seaweedfs-的文件合并存储" class="headerlink" title="目标:学习seaweedfs 的文件合并存储"></a>目标:学习seaweedfs 的文件合并存储</h2><p>文件合并后必然会带来的一堆问题待解决,比如文件索引,响应速率等.</p>
<h2 id="学习方式-google-调试"><a href="#学习方式-google-调试" class="headerlink" title="学习方式: google + 调试"></a>学习方式: google + 调试</h2><p>github 上能找到项目的wiki文档,会介绍简单的使用.调试方案: IDEA/pycharm , 需要结合atom/vscode 的delve调试go程序,各有利弊,结合使用.</p>
<h2 id="测试用命令"><a href="#测试用命令" class="headerlink" title="测试用命令"></a>测试用命令</h2><p>启动:<br>master : weed master -mdir=/home/ubuntu/weedfs<br>volume : weed volume -dir=”/home/ubuntu/weedfs/data1” -mserver=”localhost:9333”  -port=8080<br>启用目录filter: weed filer -port=8888 -dir=/home/ubuntu/weedfs/filter1 -master=localhost:9333<br>使用:<br>curl -X POST <a href="http://localhost:9333/dir/assign" target="_blank" rel="external">http://localhost:9333/dir/assign</a> 获取fid</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://yanyiwu.com/work/2015/01/09/weed-fs-source-analysis.html" target="_blank" rel="external">分布式存储Seaweedfs源码分析</a></p>
<p><a href="http://tonybai.com/2015/08/22/intro-of-using-weedfs/" target="_blank" rel="external">tonybai的个人blog</a></p>
<p><a href="http://www.tuicool.com/articles/yyUr2e" target="_blank" rel="external">weed-fs 源码解读—分布式处理过程</a></p>
<p><a href="http://blog.csdn.net/baogang409/article/details/42105367" target="_blank" rel="external">weed-fs 源码解读</a></p>
]]></content>
      
        <categories>
            
            <category> 文件存储 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> go </tag>
            
            <tag> seaweedfs </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nodeJS入门总结]]></title>
      <url>https://makeitpossible16.github.io/%E7%BD%91%E7%AB%99%E7%9B%B8%E5%85%B3/nodeJS%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>刚做完nodeJS的课设,写了个小程序,总结一下</p>
<h2 id="程序功能"><a href="#程序功能" class="headerlink" title="程序功能"></a>程序功能</h2><p>实现简单的电商网站,能登陆,注册,浏览商品,购物车操作.</p>
<h2 id="使用技术"><a href="#使用技术" class="headerlink" title="使用技术"></a>使用技术</h2><ol>
<li>nodeJS + Express + ejs</li>
<li>mongoDB + mongoose</li>
<li>bootstrap + jquery (前端页面是在网上找的,随便改了一下)</li>
</ol>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p><a href="https://github.com/MakeItPossible16/washingMachine.git" target="_blank" rel="external">github</a></p>
<h2 id="有关mongoose"><a href="#有关mongoose" class="headerlink" title="有关mongoose"></a>有关mongoose</h2><p>mongoose实现了把mongodb中的数据进行映射,可以直接使用mongoose对数据库进行操作,比较方便.使用嵌套document时,需要创建多个Schema(类似于Java中的POJO吧).<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> contactInformationSchema = <span class="keyword">new</span> Schema(&#123;</div><div class="line">    <span class="attr">address</span>: <span class="built_in">String</span>,</div><div class="line">    <span class="attr">phone</span>: <span class="built_in">String</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> alreadyPaidSchema = <span class="keyword">new</span> Schema(&#123;</div><div class="line">    <span class="attr">productID</span>: Schema.Types.ObjectId,</div><div class="line">    <span class="attr">price</span>: <span class="built_in">Number</span>,</div><div class="line">    <span class="attr">address</span>: <span class="built_in">String</span>,</div><div class="line">    <span class="attr">phone</span>: <span class="built_in">String</span>,</div><div class="line">    <span class="attr">userName</span>: <span class="built_in">String</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> unpaidSchema = <span class="keyword">new</span> Schema(&#123;</div><div class="line">    <span class="attr">productID</span>: Schema.Types.ObjectId,</div><div class="line">    <span class="attr">price</span>: <span class="built_in">Number</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> Schema(&#123;</div><div class="line">    <span class="attr">username</span>: <span class="built_in">String</span>,</div><div class="line">    <span class="attr">password</span>: <span class="built_in">String</span>,</div><div class="line">    <span class="attr">contactInformation</span>: [contactInformationSchema],</div><div class="line">    <span class="attr">alreadyPaid</span>: [alreadyPaidSchema],</div><div class="line">    <span class="attr">unpaid</span>: [unpaidSchema]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="有关nodeJS"><a href="#有关nodeJS" class="headerlink" title="有关nodeJS"></a>有关nodeJS</h2><p>最大的优点就是回调,实现网站的并发访问. 不过缺点也不少,可能是我经验不足,记录一下掉过的坑.</p>
<h3 id="1-回调-感觉就像是不负责任地甩锅"><a href="#1-回调-感觉就像是不负责任地甩锅" class="headerlink" title="1. 回调,感觉就像是不负责任地甩锅."></a>1. 回调,感觉就像是不负责任地甩锅.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> test;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">  test = array[i];</div><div class="line">  mongooseModel.find(&#123;<span class="string">"something"</span>:test&#125;).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,document</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> test1 = test; <span class="comment">//此时的test可能已经是下一循环的值</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-回调-导致代码层层嵌套"><a href="#2-回调-导致代码层层嵌套" class="headerlink" title="2. 回调,导致代码层层嵌套"></a>2. 回调,导致代码层层嵌套</h3><h3 id="3-单进程-一旦进程发生阻塞-这个程序都会阻塞"><a href="#3-单进程-一旦进程发生阻塞-这个程序都会阻塞" class="headerlink" title="3. 单进程,一旦进程发生阻塞,这个程序都会阻塞"></a>3. 单进程,一旦进程发生阻塞,这个程序都会阻塞</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="comment">//整个程序陷入死循环</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-还是回调-导致数据库跨collection查询困难"><a href="#4-还是回调-导致数据库跨collection查询困难" class="headerlink" title="4. 还是回调,导致数据库跨collection查询困难"></a>4. 还是回调,导致数据库跨collection查询困难</h3><h3 id="5-Express-中的模板应谨慎使用"><a href="#5-Express-中的模板应谨慎使用" class="headerlink" title="5. Express 中的模板应谨慎使用."></a>5. Express 中的模板应谨慎使用.</h3><p>我在项目中大量使用了ejs模板,当初就是为了图方便,直接使用ejs,实际上模板只应在静态文件中使用,也就是能保证模板中的内容在多个页面中同时适用,对于内容变化比较的页面,还是乖乖地写接口,返回JSON数据比较靠谱.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>项目总体还是比较失败,不过也能学点东西. 比如 nodeJS , mongodb, 还有一点前端知识</p>
]]></content>
      
        <categories>
            
            <category> 网站相关 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nodeJS </tag>
            
            <tag> mongodb </tag>
            
            <tag> Express </tag>
            
            <tag> mongoose </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cloudstack 搭建总结]]></title>
      <url>https://makeitpossible16.github.io/cloudsatck%E6%90%AD%E5%BB%BA/cloudstack%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>按照官网的教程搭建<a href="http://docs.cloudstack.apache.org/projects/cloudstack-installation/en/4.8/overview/index.html" target="_blank" rel="external">cloudstack</a>,稍不注意,就出现错误.总结一下.</p>
<h2 id="子节点状态不对"><a href="#子节点状态不对" class="headerlink" title="子节点状态不对"></a>子节点状态不对</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@node3 ~]<span class="comment"># service cloudstack-agent status</span></div><div class="line"></div><div class="line">cloudstack-agent dead but subsys locked</div></pre></td></tr></table></figure>
<p>解决：管理节点防火墙问题，正常状态下计算节点应通过NFS挂载主存储,管理节点应开放8250端口</p>
<p>执行完后把cloudstack-agent 重启一下，其状态应为running</p>
<h2 id="系统VM-状态为Starting"><a href="#系统VM-状态为Starting" class="headerlink" title="系统VM 状态为Starting"></a>系统VM 状态为Starting</h2><p>解决：在数据库中将这个虚拟机的状态由“Starting”更改成“Stopped”，重新启动虚拟机即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">MySQL -uroot -p -e "<span class="keyword">update</span> cloud.vm_instance <span class="keyword">set</span> state=<span class="string">'Stopped'</span> <span class="keyword">where</span> <span class="keyword">name</span>=VMNAME</div></pre></td></tr></table></figure>
<h2 id="系统VM-状态为Running-代理状态为空（centos6-5-图形化界面下的防火墙重启会清空iptables-文件下的规则）"><a href="#系统VM-状态为Running-代理状态为空（centos6-5-图形化界面下的防火墙重启会清空iptables-文件下的规则）" class="headerlink" title="系统VM 状态为Running , 代理状态为空（centos6.5 图形化界面下的防火墙重启会清空iptables 文件下的规则）"></a>系统VM 状态为Running , 代理状态为空（centos6.5 图形化界面下的防火墙重启会清空iptables 文件下的规则）</h2><p>防火墙问题</p>
<p>管理节点也用作计算节点，防火墙状态应为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Thu Jun  2 13:23:26 2016</span></div><div class="line">*nat</div><div class="line">:PREROUTING ACCEPT [187042:40599771]</div><div class="line">:POSTROUTING ACCEPT [36644:2281945]</div><div class="line">:OUTPUT ACCEPT [36644:2281945]</div><div class="line">COMMIT</div><div class="line"><span class="comment"># Completed on Thu Jun  2 13:23:26 2016</span></div><div class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Thu Jun  2 13:23:26 2016</span></div><div class="line">*filter</div><div class="line">:INPUT ACCEPT [0:0]</div><div class="line">:FORWARD ACCEPT [0:0]</div><div class="line">:OUTPUT ACCEPT [13422:54204084]</div><div class="line">:BF-cloud0 - [0:0]</div><div class="line">:BF-cloud0-IN - [0:0]</div><div class="line">:BF-cloud0-OUT - [0:0]</div><div class="line">-A INPUT -p tcp -m tcp --dport 49152:49216 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 5900:6100 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 16509 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 1798 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT</div><div class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class="line">-A INPUT -p icmp -j ACCEPT</div><div class="line">-A INPUT -i lo -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5900 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5901 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5902 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8250 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p udp -m state --state NEW -m udp --dport 111 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p tcp -m state --state NEW -m tcp --dport 111 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p tcp -m state --state NEW -m tcp --dport 2049 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p tcp -m state --state NEW -m tcp --dport 32803 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p udp -m state --state NEW -m udp --dport 32769 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p tcp -m state --state NEW -m tcp --dport 892 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p udp -m state --state NEW -m udp --dport 892 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p tcp -m state --state NEW -m tcp --dport 875 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p udp -m state --state NEW -m udp --dport 875 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p tcp -m state --state NEW -m tcp --dport 662 -j ACCEPT</div><div class="line">-A INPUT <span class="_">-s</span> 172.31.156.0/24 -p udp -m state --state NEW -m udp --dport 662 -j ACCEPT</div><div class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</div><div class="line">-A FORWARD -o cloud0 -m physdev --physdev-is-bridged -j BF-cloud0</div><div class="line">-A FORWARD -i cloud0 -m physdev --physdev-is-bridged -j BF-cloud0</div><div class="line">-A FORWARD -o cloud0 -j DROP</div><div class="line">-A FORWARD -i cloud0 -j DROP</div><div class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</div><div class="line">-A BF-cloud0 -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class="line">-A BF-cloud0 -m physdev --physdev-is-in --physdev-is-bridged -j BF-cloud0-IN</div><div class="line">-A BF-cloud0 -m physdev --physdev-is-out --physdev-is-bridged -j BF-cloud0-OUT</div><div class="line">-A BF-cloud0 -m physdev --physdev-out vnet0 --physdev-is-bridged -j ACCEPT</div><div class="line">COMMIT</div><div class="line"><span class="comment"># Completed on Thu Jun  2 13:23:26 2016</span></div></pre></td></tr></table></figure>
<p>计算节点防火墙状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Wed Jun  1 19:37:24 2016</span></div><div class="line">*mangle</div><div class="line">:PREROUTING ACCEPT [654:130068]</div><div class="line">:INPUT ACCEPT [210:107800]</div><div class="line">:FORWARD ACCEPT [0:0]</div><div class="line">:OUTPUT ACCEPT [143:8276]</div><div class="line">:POSTROUTING ACCEPT [143:8276]</div><div class="line">-A POSTROUTING -o virbr0 -p udp -m udp --dport 68 -j CHECKSUM --checksum-fill</div><div class="line">-A POSTROUTING -o virbr0 -p udp -m udp --dport 68 -j CHECKSUM --checksum-fill</div><div class="line">COMMIT</div><div class="line"><span class="comment"># Completed on Wed Jun  1 19:37:24 2016</span></div><div class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Wed Jun  1 19:37:24 2016</span></div><div class="line">*nat</div><div class="line">:PREROUTING ACCEPT [0:0]</div><div class="line">:POSTROUTING ACCEPT [0:0]</div><div class="line">:OUTPUT ACCEPT [0:0]</div><div class="line">COMMIT</div><div class="line"><span class="comment"># Completed on Wed Jun  1 19:37:24 2016</span></div><div class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Wed Jun  1 19:37:24 2016</span></div><div class="line">*filter</div><div class="line">:INPUT ACCEPT [0:0]</div><div class="line">:FORWARD ACCEPT [0:0]</div><div class="line">:OUTPUT ACCEPT [0:0]</div><div class="line">-A INPUT -i virbr0 -p udp -m udp --dport 53 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p tcp -m tcp --dport 53 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p udp -m udp --dport 67 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p tcp -m tcp --dport 67 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p udp -m udp --dport 53 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p tcp -m tcp --dport 53 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p udp -m udp --dport 67 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p tcp -m tcp --dport 67 -j ACCEPT</div><div class="line">-A INPUT -i virbr0 -p tcp -m tcp --dport 67 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 49152:49216 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 5900:6100 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 16509 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 1798 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m tcp --dport 22 -j ACCEPT</div><div class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</div><div class="line">-A INPUT -p icmp -j ACCEPT</div><div class="line">-A INPUT -i lo -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</div><div class="line">-A INPUT -p udp -m state --state NEW -m udp --dport 5900 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 5901 -j ACCEPT</div><div class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8250 -j ACCEPT</div><div class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</div><div class="line">-A FORWARD -i virbr0 -o virbr0 -j ACCEPT</div><div class="line">-A FORWARD -o virbr0 -j REJECT --reject-with icmp-port-unreachable</div><div class="line">-A FORWARD -i virbr0 -j REJECT --reject-with icmp-port-unreachable</div><div class="line">COMMIT</div><div class="line"><span class="comment"># Completed on Wed Jun  1 19:37:24 2016</span></div></pre></td></tr></table></figure>
<h2 id="二级存储及主存储路径需要设置权限，否则二级存储虽能挂载，但无法写入文件"><a href="#二级存储及主存储路径需要设置权限，否则二级存储虽能挂载，但无法写入文件" class="headerlink" title="二级存储及主存储路径需要设置权限，否则二级存储虽能挂载，但无法写入文件"></a>二级存储及主存储路径需要设置权限，否则二级存储虽能挂载，但无法写入文件</h2><h2 id="注意看日志文件，里面有详细的输出说明"><a href="#注意看日志文件，里面有详细的输出说明" class="headerlink" title="注意看日志文件，里面有详细的输出说明"></a>注意看日志文件，里面有详细的输出说明</h2>]]></content>
      
        <categories>
            
            <category> cloudsatck搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cloudsatck </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ubuntu下如何优雅地使用翻译]]></title>
      <url>https://makeitpossible16.github.io/%E6%9C%89%E9%81%93%E5%AD%97%E5%85%B8%E4%BF%AE%E6%94%B9/ubuntu%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8%E7%BF%BB%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>最近看英文文档比较多，但英语水平不咋地，需要借助翻译工具。在ubuntu下，有startdict、goldendict等字典，但字典毕竟是字典，解释太多，用着不太爽。平时喜欢用谷歌翻译，最近谷歌翻译的水平也的确提升了不少，可惜没有客户端，平时看个PDF啥的也用不了，github 上的发现mtranslate模块，把网址改为中国的网址，得到结果还挺快.</p>
<p>本来想写个接口封装一下，直接用goldendict显示的，无奈网络延迟太大，谷歌翻译都没出结果，字典的弹框就出来了，能找到goldendict的源码，但看到那一坨代码，实在没有修改的欲望。偶然的机会，发现了某道有ubuntu的客户端，解压出来，居然是python的代码，还是python大法好，这样就来优雅地改一下代码吧。<br>最后实现功能：<br>在弹框中显示调用mtranslate模块显示的翻译信息</p>
<p><img src="http://store-10069044.cos.myqcloud.com/myblogImage/20161017145304097youdao.png" alt=""></p>
<p>点击保存，将所翻译的单词保存到指定目录的translate.csv文件中</p>
<p><img src="http://store-10069044.cos.myqcloud.com/myblogImage/20161017145415567youdaoSave.png" alt=""></p>
<p>调整弹框显示，解决翻译文本过长导致弹框显示不全的问题</p>
<h1 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h1><h2 id="下载mtranslate模块"><a href="#下载mtranslate模块" class="headerlink" title="下载mtranslate模块"></a>下载<a href="https://github.com/mouuff/mtranslate" target="_blank" rel="external">mtranslate</a>模块</h2><h2 id="配置运行环境"><a href="#配置运行环境" class="headerlink" title="配置运行环境"></a>配置运行环境</h2><p>使用python3，先安装youdao的客户端，解决依赖关系，然后把youdao卸载。</p>
<h2 id="代码实现过程"><a href="#代码实现过程" class="headerlink" title="代码实现过程"></a>代码实现过程</h2><p>下载.deb包，解压，参考文章<a href="http://www.cnblogs.com/scplee/archive/2016/05/13/5489024.html" target="_blank" rel="external">http://www.cnblogs.com/scplee/archive/2016/05/13/5489024.html</a></p>
<h3 id="在dae-utils-py增加代码"><a href="#在dae-utils-py增加代码" class="headerlink" title="在dae/utils.py增加代码"></a>在dae/utils.py增加代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_conf</span><span class="params">()</span>:</span>  </div><div class="line">    <span class="keyword">import</span>  json  </div><div class="line">    <span class="keyword">import</span> os  </div><div class="line">    <span class="keyword">with</span> open(<span class="string">'configuration.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:  </div><div class="line">        conf = json.load(f)  </div><div class="line">    <span class="keyword">return</span> conf</div></pre></td></tr></table></figure>
<h3 id="修改translate-py文件"><a href="#修改translate-py文件" class="headerlink" title="修改translate.py文件"></a>修改translate.py文件</h3><p>修改get_translate方法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_translate</span><span class="params">(self, text)</span>:</span>  </div><div class="line">    data = &#123; <span class="string">"keyfrom"</span> : <span class="string">"deskdict.linux"</span>, <span class="string">"q"</span> : text.encode(<span class="string">"utf-8"</span>), <span class="string">"doctype"</span> : <span class="string">"xml"</span>, <span class="string">"xmlVersion"</span> : <span class="number">8.2</span>,  </div><div class="line">             <span class="string">"client"</span> : const.client, <span class="string">"id"</span> : <span class="string">"cee84504d9984f1b2"</span>, <span class="string">"vendor"</span>: <span class="string">"deskdict.linux"</span>,  </div><div class="line">             <span class="string">"in"</span> : <span class="string">"YoudaoDict"</span>, <span class="string">"appVer"</span> : <span class="string">"5.4.46.5554"</span>, <span class="string">"appZengqiang"</span> : <span class="number">0</span>, <span class="string">"le"</span> : <span class="string">"eng"</span>, <span class="string">"LTH"</span> : <span class="number">40</span>&#125;  </div><div class="line">    <span class="comment"># self.clear_translate()  </span></div><div class="line">    <span class="comment"># try:  </span></div><div class="line">    ret = requests.get(<span class="string">"http://dict.youdao.com/search"</span>, params=data).text  </div><div class="line">    ret = ret.encode(<span class="string">'utf-8'</span>)  </div><div class="line">    pq = PyQuery(ret, parser=<span class="string">"xml"</span>)  </div><div class="line">    test_data = &#123;<span class="string">"q"</span>: text, <span class="string">"type"</span>: <span class="number">1</span>, <span class="string">"pos"</span>: <span class="number">-1</span>, <span class="string">"client"</span>: const.client&#125;  </div><div class="line">    test_ret = json.loads(requests.get(<span class="string">"http://dict.youdao.com/jsonresult"</span>, params=test_data).text)  </div><div class="line">    self.translate_info.text = text  </div><div class="line">    text = str(text).replace(<span class="string">'\n'</span>,<span class="string">' '</span>)  </div><div class="line">    <span class="keyword">from</span> dae.utils <span class="keyword">import</span> get_conf  </div><div class="line">    conf = get_conf()  </div><div class="line">    self.translate_info.webtrans = <span class="string">"谷歌翻译:\n"</span>  </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (str(conf[<span class="string">'useTranslateModule'</span>]).upper() == <span class="string">'TRUE'</span> ):  </div><div class="line">        self.translate_info.webtrans = self.translate_info.webtrans + useTranslateComponent(text) + <span class="string">"\n"</span>  </div><div class="line">    <span class="comment"># if self.translate_info.webtrans:  </span></div><div class="line">    self.translate_info.webtrans =self.translate_info.webtrans + <span class="string">"有道:\n"</span>  </div><div class="line">    self.translate_info.trans = <span class="string">'\n'</span>.join([PyQuery(l)(<span class="string">"i"</span>).text() <span class="keyword">for</span> l <span class="keyword">in</span> pq(<span class="string">'trs l'</span>)])  </div><div class="line">    self.translate_info.phonetic = test_ret.get(<span class="string">"ussm"</span>, <span class="string">""</span>)  </div><div class="line">    self.translate_info.webtrans = self.translate_info.webtrans + self.wrap_web_trans(pq)  </div><div class="line"></div><div class="line">    <span class="comment">#     self.translate_info.lang = test_ret.get("lang", "")  </span></div><div class="line">    <span class="comment">#  </span></div><div class="line">    <span class="comment"># except:  </span></div><div class="line">    <span class="comment">#     with open_offline_dict() as obj:  </span></div><div class="line">    <span class="comment">#         ret = obj.query(text)  </span></div><div class="line">    <span class="comment">#         if ret:  </span></div><div class="line">    <span class="comment">#             self.translate_info.text = text  </span></div><div class="line">    <span class="comment">#             self.translate_info.trans = ret[1].replace("\\n", "\n")  </span></div><div class="line">    <span class="comment">#             self.translate_info.phonetic = ret[0][1:-1]  </span></div><div class="line">    <span class="comment">#             self.translate_info.webtrans = "抱歉，从网络获取结果失败，请检测网络重试"  </span></div><div class="line">    <span class="comment">#             self.translate_info.lang = "eng"  </span></div><div class="line">    <span class="comment"># self.translate_info.voices = get_voice_simple(text)  </span></div><div class="line">    <span class="comment"># if not text:  </span></div><div class="line">    <span class="comment">#     return  </span></div><div class="line">    <span class="comment">#self.clear_translate()  </span></div><div class="line"></div><div class="line">    <span class="comment">#self.translate_info.text = text  </span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.translate_info.webtrans:  </div><div class="line">        self.translate_info.webtrans = <span class="string">"查询失败"</span>  </div><div class="line">    <span class="keyword">if</span> self.translate_info.webtrans:  </div><div class="line">        self.translateFinished.emit()</div></pre></td></tr></table></figure></p>
<h3 id="在translate-py中添加代码："><a href="#在translate-py中添加代码：" class="headerlink" title="在translate.py中添加代码："></a>在translate.py中添加代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">useTranslateComponent</span><span class="params">(text)</span>:</span>  </div><div class="line">    <span class="keyword">import</span> os</div><div class="line">    <span class="keyword">from</span> dae.utils <span class="keyword">import</span> get_conf</div><div class="line">    conf = get_conf()</div><div class="line">    toLang = conf[<span class="string">'toLang'</span>]</div><div class="line">    <span class="keyword">from</span> mtranslate <span class="keyword">import</span> translate</div><div class="line">    translation = translate(text,toLang)</div><div class="line">    <span class="keyword">return</span> translation</div></pre></td></tr></table></figure>
<h3 id="在windows-py添加类："><a href="#在windows-py添加类：" class="headerlink" title="在windows.py添加类："></a>在windows.py添加类：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#@ 保存到文件  </span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">saveToFile</span><span class="params">(QtCore.QObject)</span>:</span>  </div><div class="line"><span class="meta">    @QtCore.pyqtSlot(str, str)  </span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">saveToFile</span><span class="params">(self,fromText,toText)</span>:</span>  </div><div class="line">        <span class="keyword">import</span> os  </div><div class="line">        <span class="keyword">import</span> csv  </div><div class="line">        <span class="keyword">from</span> dae.utils <span class="keyword">import</span> get_conf  </div><div class="line">        toText = str(toText).replace(<span class="string">'谷歌翻译:'</span>,<span class="string">''</span>)  </div><div class="line">        toText = toText.split(<span class="string">'有道:'</span>)  </div><div class="line">        firstText = <span class="string">''</span>  </div><div class="line">        <span class="keyword">if</span> toText[<span class="number">0</span>]:  </div><div class="line">            firstText = toText[<span class="number">0</span>].strip(<span class="string">'\n'</span>)  </div><div class="line">        lastText = toText[<span class="number">1</span>].replace(<span class="string">'有道:'</span>,<span class="string">''</span>).strip(<span class="string">'\n'</span>).lstrip(<span class="string">'w. '</span>)  </div><div class="line">        <span class="keyword">if</span> (firstText <span class="keyword">or</span> lastText):  </div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> firstText:  </div><div class="line">                firstText = <span class="string">' '</span>  </div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> lastText:  </div><div class="line">                lastText = <span class="string">' '</span>  </div><div class="line">            conf = get_conf()  </div><div class="line">            savePath = str(conf[<span class="string">'savePath'</span>]).rstrip(<span class="string">'/'</span>) + <span class="string">'/translate.csv'</span>  </div><div class="line"></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(savePath):  </div><div class="line">                <span class="keyword">with</span> open(savePath,<span class="string">'a+'</span>) <span class="keyword">as</span> f:  </div><div class="line">                    writer = csv.writer(f)  </div><div class="line">                    writer.writerow([<span class="string">'翻译内容'</span>,<span class="string">'谷歌翻译'</span>,<span class="string">'有道词典'</span>])  </div><div class="line">                    writeData = [  </div><div class="line">                        fromText, firstText, lastText  </div><div class="line">                    ]  </div><div class="line">                    writer.writerow(writeData)  </div><div class="line">                    f.close()  </div><div class="line">                <span class="keyword">return</span>  </div><div class="line">            <span class="keyword">with</span> open(savePath,<span class="string">'a+'</span>) <span class="keyword">as</span> f:  </div><div class="line">                writer = csv.writer(f)  </div><div class="line">                writeData = [  </div><div class="line">                    fromText, firstText, lastText  </div><div class="line">                ]  </div><div class="line">                writer.writerow(writeData)  </div><div class="line">                f.close()  </div><div class="line">            <span class="keyword">return</span>  </div><div class="line">        <span class="keyword">return</span></div></pre></td></tr></table></figure>
<h3 id="在window-py-的init-方法中添加代码"><a href="#在window-py-的init-方法中添加代码" class="headerlink" title="在window.py 的init()方法中添加代码"></a>在window.py 的<strong>init</strong>()方法中添加代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#@ 单词保存到文件  </span></div><div class="line">        self.saveToFile = saveToFile()  </div><div class="line">        self.qml_context.setContextProperty(<span class="string">"saveToFile"</span>, self.saveToFile) <span class="comment">#把saveToFile类暴露给qml文件</span></div></pre></td></tr></table></figure>
<h3 id="在TranslateContent-qml-添加TextEdit，位置自己看着办就行"><a href="#在TranslateContent-qml-添加TextEdit，位置自己看着办就行" class="headerlink" title="在TranslateContent.qml 添加TextEdit，位置自己看着办就行"></a>在TranslateContent.qml 添加TextEdit，位置自己看着办就行</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">TextEdit&#123;  </div><div class="line">            <span class="attr">color</span>: <span class="string">"#ff0000"</span>  </div><div class="line">            anchors.verticalCenter: parent.verticalCenter  </div><div class="line">            text: <span class="string">" 保存"</span>  </div><div class="line">            selectByMouse: <span class="literal">true</span>  </div><div class="line">            readOnly: <span class="literal">true</span>  </div><div class="line">            font.pixelSize: <span class="number">15</span>  </div><div class="line">            MouseArea &#123;  </div><div class="line">                anchors.fill: parent  </div><div class="line">                hoverEnabled: <span class="literal">true</span>  </div><div class="line">                onExited: &#123;  </div><div class="line">                    cursorShape = Qt.ArrowCursor  </div><div class="line">                &#125;  </div><div class="line">                onClicked: &#123;  </div><div class="line">                    saveToFile.saveToFile(translateInfo.text, translateInfo.webtrans)  </div><div class="line">                    <span class="keyword">if</span> (parent.color == <span class="string">"#2699eb"</span>)&#123;  </div><div class="line">                        parent.color = <span class="string">"#ff0000"</span>;  </div><div class="line">                    &#125;  </div><div class="line">                    <span class="keyword">else</span>&#123;  </div><div class="line">                        <span class="keyword">if</span>(parent.color == <span class="string">"#ff0000"</span>)&#123;  </div><div class="line">                            parent.color = <span class="string">"#2699eb"</span>  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h3 id="修改翻译内容显示方式"><a href="#修改翻译内容显示方式" class="headerlink" title="修改翻译内容显示方式"></a>修改翻译内容显示方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">TextEdit&#123;  </div><div class="line">            <span class="attr">id</span>: keywordsText  </div><div class="line">            width: parent.width  </div><div class="line">            <span class="comment">//anchors.verticalCenter: parent.verticalCenter  </span></div><div class="line">            selectByMouse: <span class="literal">true</span>  </div><div class="line">            readOnly: <span class="literal">true</span>  </div><div class="line">            text: translateInfo.text  </div><div class="line">            wrapMode: Text.WordWrap  </div><div class="line">            font.pixelSize: <span class="number">13</span>  </div><div class="line">            font.bold: <span class="literal">true</span>  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><p>在main.py所在文件夹下添加配置文件configuration.json，配置文件，可以选择是否启用translate模块，配置保存翻译信息文件位置，使用translate时系统调用的命令<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">  <span class="attr">"useTranslateModule"</span>: <span class="string">"true"</span>,  </div><div class="line">  <span class="attr">"savePath"</span>: <span class="string">"/home/ubuntu/Desktop"</span>,  </div><div class="line">  <span class="attr">"cmd"</span>: <span class="string">"translate -f en -t zh "</span>,</div><div class="line">  <span class="attr">"toLang"</span>: <span class="string">"zh"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>直接运行main.py youdao-dict-backend.py就行, 可写个简单的脚本来实现</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>直接利用youdao原有的事件处理，总体能用，但没有startdict或goldendict流畅，如果能直接修改startdict或goldendict的代码，利用它们的事件处理，估计会更稳定，不过最近比较忙,先凑合着用吧.</p>
]]></content>
      
        <categories>
            
            <category> 有道字典修改 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[github目录]]></title>
      <url>https://makeitpossible16.github.io/uncategorized/README/</url>
      <content type="html"><![CDATA[<h2 id="blogMarkdownFile"><a href="#blogMarkdownFile" class="headerlink" title="blogMarkdownFile"></a>blogMarkdownFile</h2><h2 id="myblog"><a href="#myblog" class="headerlink" title="myblog"></a><a href="https://www.makeitpossible16.github.io" target="_blank" rel="external">myblog</a></h2><h3 id="转-Leveldb实现原理Leveldb实现原理-md"><a href="#转-Leveldb实现原理Leveldb实现原理-md" class="headerlink" title="(转)Leveldb实现原理Leveldb实现原理.md)"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/(转" target="_blank" rel="external">(转)Leveldb实现原理</a>Leveldb实现原理.md)</h3><h3 id="C-语法记录"><a href="#C-语法记录" class="headerlink" title="C++语法记录"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/C++语法记录.md" target="_blank" rel="external">C++语法记录</a></h3><h3 id="ELKStack搭建问题总结"><a href="#ELKStack搭建问题总结" class="headerlink" title="ELKStack搭建问题总结"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/ELKStack搭建问题总结.md" target="_blank" rel="external">ELKStack搭建问题总结</a></h3><h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/LRU缓存淘汰算法.md" target="_blank" rel="external">LRU缓存淘汰算法</a></h3><h3 id="LeetCode解题-Next-Permutation-全排列生成算法-md"><a href="#LeetCode解题-Next-Permutation-全排列生成算法-md" class="headerlink" title="LeetCode解题-Next Permutation(全排列生成算法).md)"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/LeetCode解题-Next Permutation(全排列生成算法" target="_blank" rel="external">LeetCode解题-Next Permutation(全排列生成算法)</a>.md)</h3><h3 id="LeetCode解题-Permutation-Sequence"><a href="#LeetCode解题-Permutation-Sequence" class="headerlink" title="LeetCode解题-Permutation Sequence"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/LeetCode解题-Permutation Sequence.md" target="_blank" rel="external">LeetCode解题-Permutation Sequence</a></h3><h3 id="cloudstack搭建总结"><a href="#cloudstack搭建总结" class="headerlink" title="cloudstack搭建总结"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/cloudstack搭建总结.md" target="_blank" rel="external">cloudstack搭建总结</a></h3><h3 id="gdb调试错误-找不到文件"><a href="#gdb调试错误-找不到文件" class="headerlink" title="gdb调试错误-找不到文件"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/gdb调试错误-找不到文件.md" target="_blank" rel="external">gdb调试错误-找不到文件</a></h3><h3 id="golang-反射机制"><a href="#golang-反射机制" class="headerlink" title="golang 反射机制"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/golang 反射机制.md" target="_blank" rel="external">golang 反射机制</a></h3><h3 id="golang学习"><a href="#golang学习" class="headerlink" title="golang学习"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/golang学习.md" target="_blank" rel="external">golang学习</a></h3><h3 id="golang调试技巧"><a href="#golang调试技巧" class="headerlink" title="golang调试技巧"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/golang调试技巧.md" target="_blank" rel="external">golang调试技巧</a></h3><h3 id="kafka存储实现"><a href="#kafka存储实现" class="headerlink" title="kafka存储实现"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/kafka存储实现.md" target="_blank" rel="external">kafka存储实现</a></h3><h3 id="kafka学习笔记"><a href="#kafka学习笔记" class="headerlink" title="kafka学习笔记"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/kafka学习笔记.md" target="_blank" rel="external">kafka学习笔记</a></h3><h3 id="linux-IO学习"><a href="#linux-IO学习" class="headerlink" title="linux IO学习"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux IO学习.md" target="_blank" rel="external">linux IO学习</a></h3><h3 id="linux内核学习-数据结构"><a href="#linux内核学习-数据结构" class="headerlink" title="linux内核学习-数据结构"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux内核学习-数据结构.md" target="_blank" rel="external">linux内核学习-数据结构</a></h3><h3 id="linux单文件大小限制"><a href="#linux单文件大小限制" class="headerlink" title="linux单文件大小限制"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux单文件大小限制.md" target="_blank" rel="external">linux单文件大小限制</a></h3><h3 id="linux命令学习"><a href="#linux命令学习" class="headerlink" title="linux命令学习"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux命令学习.md" target="_blank" rel="external">linux命令学习</a></h3><h3 id="linux学习-linux文件存储"><a href="#linux学习-linux文件存储" class="headerlink" title="linux学习-linux文件存储"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux学习-linux文件存储.md" target="_blank" rel="external">linux学习-linux文件存储</a></h3><h3 id="linux文件存储机制"><a href="#linux文件存储机制" class="headerlink" title="linux文件存储机制"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux文件存储机制.md" target="_blank" rel="external">linux文件存储机制</a></h3><h3 id="linux页缓存机制-Page-Cache"><a href="#linux页缓存机制-Page-Cache" class="headerlink" title="linux页缓存机制 Page Cache"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/linux页缓存机制 Page Cache.md" target="_blank" rel="external">linux页缓存机制 Page Cache</a></h3><h3 id="nodeJS入门总结"><a href="#nodeJS入门总结" class="headerlink" title="nodeJS入门总结"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/nodeJS入门总结.md" target="_blank" rel="external">nodeJS入门总结</a></h3><h3 id="openstack-swift源码阅读记录1-文件上传过程"><a href="#openstack-swift源码阅读记录1-文件上传过程" class="headerlink" title="openstack-swift源码阅读记录1-文件上传过程"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/openstack-swift源码阅读记录1-文件上传过程.md" target="_blank" rel="external">openstack-swift源码阅读记录1-文件上传过程</a></h3><h3 id="openstack-swift源码阅读记录3-diskfile"><a href="#openstack-swift源码阅读记录3-diskfile" class="headerlink" title="openstack-swift源码阅读记录3-diskfile"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/openstack-swift源码阅读记录3-diskfile.md" target="_blank" rel="external">openstack-swift源码阅读记录3-diskfile</a></h3><h3 id="openstack-swift源码阅读记录4-启用mem-diskfile"><a href="#openstack-swift源码阅读记录4-启用mem-diskfile" class="headerlink" title="openstack-swift源码阅读记录4-启用mem_diskfile"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/openstack-swift源码阅读记录4-启用mem_diskfile.md" target="_blank" rel="external">openstack-swift源码阅读记录4-启用mem_diskfile</a></h3><h3 id="openstack-swift调试"><a href="#openstack-swift调试" class="headerlink" title="openstack-swift调试"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/openstack-swift调试.md" target="_blank" rel="external">openstack-swift调试</a></h3><h3 id="openstack源码阅读记录2-object-metadata"><a href="#openstack源码阅读记录2-object-metadata" class="headerlink" title="openstack源码阅读记录2-object metadata"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/openstack源码阅读记录2-object metadata.md" target="_blank" rel="external">openstack源码阅读记录2-object metadata</a></h3><h3 id="python的多线程和Goroutine"><a href="#python的多线程和Goroutine" class="headerlink" title="python的多线程和Goroutine"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/python的多线程和Goroutine.md" target="_blank" rel="external">python的多线程和Goroutine</a></h3><h3 id="python语法记录"><a href="#python语法记录" class="headerlink" title="python语法记录"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/python语法记录.md" target="_blank" rel="external">python语法记录</a></h3><h3 id="seaweedfs源码阅读4-volume启动"><a href="#seaweedfs源码阅读4-volume启动" class="headerlink" title="seaweedfs源码阅读4-volume启动"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读4-volume启动.md" target="_blank" rel="external">seaweedfs源码阅读4-volume启动</a></h3><h3 id="seaweedfs源码阅读5-文件PUT过程"><a href="#seaweedfs源码阅读5-文件PUT过程" class="headerlink" title="seaweedfs源码阅读5-文件PUT过程"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读5-文件PUT过程.md" target="_blank" rel="external">seaweedfs源码阅读5-文件PUT过程</a></h3><h3 id="seaweedfs源码阅读6-文件存储格式"><a href="#seaweedfs源码阅读6-文件存储格式" class="headerlink" title="seaweedfs源码阅读6-文件存储格式"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读6-文件存储格式.md" target="_blank" rel="external">seaweedfs源码阅读6-文件存储格式</a></h3><h3 id="seaweedfs源码阅读7-文件存储过程"><a href="#seaweedfs源码阅读7-文件存储过程" class="headerlink" title="seaweedfs源码阅读7-文件存储过程"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读7-文件存储过程.md" target="_blank" rel="external">seaweedfs源码阅读7-文件存储过程</a></h3><h3 id="seaweedfs源码阅读8-GET-amp-HEAD获取文件过程"><a href="#seaweedfs源码阅读8-GET-amp-HEAD获取文件过程" class="headerlink" title="seaweedfs源码阅读8-GET&amp;HEAD获取文件过程"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读8-GET&amp;HEAD获取文件过程.md" target="_blank" rel="external">seaweedfs源码阅读8-GET&amp;HEAD获取文件过程</a></h3><h3 id="seaweedfs源码阅读记录"><a href="#seaweedfs源码阅读记录" class="headerlink" title="seaweedfs源码阅读记录"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读记录.md" target="_blank" rel="external">seaweedfs源码阅读记录</a></h3><h3 id="seaweedfs源码阅读记录2"><a href="#seaweedfs源码阅读记录2" class="headerlink" title="seaweedfs源码阅读记录2"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读记录2.md" target="_blank" rel="external">seaweedfs源码阅读记录2</a></h3><h3 id="seaweedfs源码阅读记录3-raft协议理解"><a href="#seaweedfs源码阅读记录3-raft协议理解" class="headerlink" title="seaweedfs源码阅读记录3-raft协议理解"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读记录3-raft协议理解.md" target="_blank" rel="external">seaweedfs源码阅读记录3-raft协议理解</a></h3><h3 id="seaweedfs源码阅读记录9-生成fid过程"><a href="#seaweedfs源码阅读记录9-生成fid过程" class="headerlink" title="seaweedfs源码阅读记录9-生成fid过程"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/seaweedfs源码阅读记录9-生成fid过程.md" target="_blank" rel="external">seaweedfs源码阅读记录9-生成fid过程</a></h3><h3 id="swift-weedfs-backend-diskfile代码实现"><a href="#swift-weedfs-backend-diskfile代码实现" class="headerlink" title="swift-weedfs-backend diskfile代码实现"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/swift-weedfs-backend diskfile代码实现.md" target="_blank" rel="external">swift-weedfs-backend diskfile代码实现</a></h3><h3 id="swift-weedfs-backend接口设计"><a href="#swift-weedfs-backend接口设计" class="headerlink" title="swift-weedfs-backend接口设计"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/swift-weedfs-backend接口设计.md" target="_blank" rel="external">swift-weedfs-backend接口设计</a></h3><h3 id="ubuntu下如何优雅地使用翻译"><a href="#ubuntu下如何优雅地使用翻译" class="headerlink" title="ubuntu下如何优雅地使用翻译"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/ubuntu下如何优雅地使用翻译.md" target="_blank" rel="external">ubuntu下如何优雅地使用翻译</a></h3><h3 id="ubuntu使用问题总结"><a href="#ubuntu使用问题总结" class="headerlink" title="ubuntu使用问题总结"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/ubuntu使用问题总结.md" target="_blank" rel="external">ubuntu使用问题总结</a></h3><h3 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/伪随机数.md" target="_blank" rel="external">伪随机数</a></h3><h3 id="在Openstack-Swift中使用多种后端存储实现"><a href="#在Openstack-Swift中使用多种后端存储实现" class="headerlink" title="在Openstack Swift中使用多种后端存储实现"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/在Openstack Swift中使用多种后端存储实现.md" target="_blank" rel="external">在Openstack Swift中使用多种后端存储实现</a></h3><h3 id="对象存储VS文件系统"><a href="#对象存储VS文件系统" class="headerlink" title="对象存储VS文件系统"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/对象存储VS文件系统.md" target="_blank" rel="external">对象存储VS文件系统</a></h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/数据结构.md" target="_blank" rel="external">数据结构</a></h3><h3 id="文件系统-seaweedfs-与关系型数据库优劣势分析与关系型数据库优劣势分析-md"><a href="#文件系统-seaweedfs-与关系型数据库优劣势分析与关系型数据库优劣势分析-md" class="headerlink" title="文件系统(seaweedfs)与关系型数据库优劣势分析与关系型数据库优劣势分析.md)"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/文件系统(seaweedfs" target="_blank" rel="external">文件系统(seaweedfs)与关系型数据库优劣势分析</a>与关系型数据库优劣势分析.md)</h3><h3 id="用户态到内核态切换"><a href="#用户态到内核态切换" class="headerlink" title="用户态到内核态切换"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/用户态到内核态切换.md" target="_blank" rel="external">用户态到内核态切换</a></h3><h3 id="自旋锁spinlock剖析与改进"><a href="#自旋锁spinlock剖析与改进" class="headerlink" title="自旋锁spinlock剖析与改进"></a><a href="https://github.com/MakeItPossible16/blogMarkdownFile/blob/master/自旋锁spinlock剖析与改进.md" target="_blank" rel="external">自旋锁spinlock剖析与改进</a></h3>]]></content>
      
        
    </entry>
    
  
  
</search>
